# 보안 10주차 이론

7장 뒤에 3장 못한 부분

앞에 언급한 mode들이 실제 어디에서 쓰이냐 예시들

Example: IEEE 802.11
무선랜에 관한 내용들.

AES-CCMP
(CTR with CBC-MAC protocol)
기밀성은 카운터로,
무결성은 CBC로로 보장한다는 뜻

Example : TLS v1.3
Transport Layer Security
transport 계층에서 보안을 위한 표준

21)
요약

————————————————————————————————————

9장. Public key cryptography and RSA

8장은 나중에.

2)
내용

3)
3장에서 시메트릭 크립토시스템 모델 복습

공격자는 플레인텍스트 X나 K를 알아낼 수 없어야함

Key를 어떻게 안전하게 보낼것이냐가 중요한 이슈
-> 어떻게 이 문제를 해결할 것이냐, 공개키 암호에서 이 문제를 해결

4)
공개키암호(pblic-key cryptosystem)에서는 그렇게 하지 않을 것이다.

대칭 암호에 있어서 해결 안되는 2가지 문제
- 키 전송 문제 어떻게 양쪽에 키를 안전하게 전송할것인가
- 전자서명(부인방지) 문제 이 메세지가 유일하게 sender가 보냈다는 사실을 인증할 방법이 없음. 왜냐하면 key는 최소 2명(수신자, 송신자)가 가지기 때문에.  ex) CBC-MAC을 이용하여 authentication을 한다고 하면,

![보안 10주차 이론](images/보안%2010주차%20이론.png)

	송신자는 key를 가지고 C를 만들고, 마지막 C 한블럭을 붙여서 보내서 	수신자는 key를 이용하여 전체를 복호화하고, 그걸 다시 암호화해서 마지막 C 한 블럭을 송신자가 보낸거랑 비교 => 같으면 그 사람이 보낸게 맞구나, 중간에 오류나 공격이 없었구나 인증. 	이게 message authentication code 였고 integrityd와 authentication을 보장해 주었는데,

	A가 B에게 계약에 관한 내용을 암호화하여 보낸다고 가정
	P : A는 B에게 계약수행 대가로 000원을 지불해야한다.
	B는 이 암호화된 내용을 복호화해서 확인 후 A가 보낸게 맞으니까 계약수행
	그런데 A가 돈을 지불하지 않음

	법정에 가서, 그 메세지를 A가 보냈다는 것을 증명해야하는데 A가 만든건지 B가 만든건지 증명할 방법 없음. 둘 다 key를 가지고 있으니까.
	따라서 해당 메세지가 송신자로부터 유일하게 보내졌다는 증명방법이 없다.

이러한 이슈를 처음 해결한 사람들이 Diffie, Hellman
공캐기 암호의 시초.
이걸 이용해서 나중에 RSA가 나옴

5)
공개키암호에 대한 개념들

public key(공개키) : P를 인크립션 알고리즘으로 암호화할 떄 필요한 키
private key(개인키) : C를 디크립션 알고리즘으로 복호화할 때 필요한 키

6)
예시.

공개키 : 누구나 다 가지고 있음
개인키 : 본인만 가지고 있음
-> 두 개가 같이 작용

보통 개인이 공개키-개인키 pair를 생성함

(a)
공개키를 이용하여 플레인텍스트를 암호화하는 과정

Bob이 Alice의 공개키를 이용하여 plain text를 암호화
(공개키는 누구나 다 가지고 있으므로 이 과정은 누구나 가능)
Alice는 개인키를 이용하여 해당 싸이퍼 텍스트 복호화
(개인키는 본인만 가지고 있으므로 본인만 가능)

-> key distribution 문제해결.
안전한 채널로 키를 주고 받을 필요 없다.

(b)
개인키를 이용하여 전자서명하는 과정

Bob이 본인의 개인키를 이용하여 plain text에 전자서명(digital signature)을 generation. (이 과정은 암호하라기 보단 plaintext + digital signature를 보냄)
Alice는 Bob의 공개키를 이용하여 전자서명을 복호화하고 해당 plain text가 Bob으로부터 온 것임을 verification 할 수 있음

-> 전자서명(부인방지)문제 해결

7)
대칭키(symmetric key) 알고리즘(conventional)과  공개키(public key) 알고리즘 비교

- symmetric key
필요조건)
-암호화 복호화 시 같은 알고리즘과 같은 키 사용
-따라서 송신자 수신자는 알고리즘과 키를 반드시 공유해야함

안전을 위한 조건)
-키는 반드시 안전하게 전해져야한다.
-키가 없으면 복호화는 불가능하다.
-알고리즘을 알고, 평문과 비문의 쌍을 몇가지 알아도 키를 알아낼 수 없다.

- public-key
필요조건)
-키의 쌍을 가지고 동작하며 한 개의 키는 암호화, 한 개의 키는 복호화하는데 사용된다
-송신자와 수신자는 match되는 키의 쌍 중 각각 하나(개인키)를 가지고 있어야한다.

안전을 위한 조건)
-키 2개중 하나(개인키)는 안전하게 가지고 있어야한다.
-개인키가 없으면 복호화 불가능
-알고리즘과 공개키, 평문과 비문의 쌍을 알아도 개인키를 알아낼 수 없다.

8)
앞에서의 과정 다시 정리

공개키를 이용하여 암호화 시키는 과정(Confidentiality)

수신자가 보통 key pair을 만들어서 개인키는 가지고 공개키는 공유
(PU : 공개키, PR : 개인키)

송신자는 PU를 이용하여 암호화,
수신자는 PR를 이용하여 복호화

공격자는 비문 + PU만 가지고 평문 또는 PR을 알 수 없음

9)
개인키를 이용하여 전자서명 과정(Authentication, integrity, not repudiation 이 한꺼번에 제공됨)

송신자는 PR을 이용하여 signature generation 진행(편의상 encryption이라고 표현)
수신자는 PU를 이용하여 서명확인(verificaiton) (편의상 decryption이라고 표현)

공격자는 서명과 PU를 가지고 PR를 알아내는게 목표
또는 PR을 가지고 새로운 서명을 만들어내는게 목표

전자서명의 역할
Authentication, integrity, not repudiation 이었다.
MAC으로는 해결하지 못했던 not repudiation까지 해결.

+) 서명이라는게 plain text와 연관관계를 가지고 온거라서, plain text와 서명이 맞아떨어진다는 것은 송신 중간게 오류나 변조가 없음을 말한다 -> integrity도 보장

해당 PR을 가지고 있는 사람은 송신자뿐이므로 Authentication도 가능

not repudiation도 PR키는 송신자만 가지고 있으므로 부인방지 가능.

10)
대칭암호에서 인크립션할때 카운터모드 쓰고
MAC할때 CBC쓰는데 둘다 하고 싶을 수 있잖아.
confidentiality, integrity, authentication 다 하고 싶을 떄
-> 카운터모드에 CBC-MAC을 붙여서 CCMP같은걸 쓴다.
이런 얘기를 했었다.

공개키암호에서도,
데이터도 숨기고 싶고 내가 보냈다라는걸 확인도 시켜주고 싶을 때
공개키 개인키 둘다 사용

A가 B에게 보낸다.
A는
- PRa를 이용하여 전자서명 만듬
- PUb를 이용하여 인크립션

B는
- PRb를 이용하여 디크립션하고
- PUa를 이용하여 전자서명 확인

11)
공개키 암호를 이용하는 응용분야

- encryption/decrpytion
- digital signature
- key excahange * 키 교환 안해도 되는 거아닌가? 맞다. 하지만 공개키 암호를 만들었다고해서 symmetric key cipher를 안쓰는게 아니다. AES같은 대칭암호는 여전히 유효하다. 왜냐하면 공개키 암호는 속도가 굉장히 느려서 기능상으로 여러가지 기능을 주는 건 좋지만, 대용량의 데이터를 암호화하거나 대용량의 데이터를 인증하거나 쓸 때는 성능상으로 문제가 있다. 따라서 보통은 공개키 암호와 대칭암호를 같이 쓴다. -> 대칭암호를 쓰니까 여전히 키를 안전하게 전달하는 것에 대한 문제 존재 => 키를 안전하게 전달하는 방법으로 공개키암호를 이용가능  즉 공개키 암호 자체를 쓸 때는 키를 안전하게 전달하는 방법이 필요없지만, 대칭암호의 키 전달을 위해서 공개키암호가 사용된다는 뜻

12)
공개키암호를 이용한 여러 알고리즘

13)
공개키암호 알고리즘이 동작하기 위한 요구사항들

실용성측면과 안전성 측면이 있음

실용성측면)
- 키 pair를 generate하는 과정이 쉬워야한다
- 송신자는, 수신자의 공개키를 가지고 플레인텍스트를 암호화하는 과정이 쉬어야한다.
- 수신자는, 수신자의 개인키를 가지고 싸이퍼텍스트를 복호화하는 과정이 쉬어야한다.

안전성 측면)
- 공격자가 공개키를 알고 있어도 개인키를 알 수 없어야 한다
- 공격자가 공개키와 싸이퍼텍스트를 알아도 평문을 알 수 없어야 한다.

14)
RSA

1977년에 MIT에서 만들어짐.
개발자들인 Rivest, Shamir, Adleman의 앞글자를 따서 만듬

공개키 암호에서 가장 널리 쓰이는 알고리즘

평문 또는 비문이 비트시퀀스인데, 이를 정수 n을 모듈러스한 값인 0~ n-1수로 해석해서 숫자연산으로 동작시킨다.
최근에는 n은 최소 2048비트 숫자여야하고, 권장사항으로는 3072, 4096비트여야한다.

15)
RSA 알고리즘

- 지수 연산을 사용할 것 (밀러라빈에서 쓰였던)
- 평문은 n이라는 미리 정해진 모듈러스 숫자보다 작은 숫자로 인코딩되서, 숫자상태에서 연산이 될것
- 암호화 복호화 과정이 굉장히 간단하다. 평문이 n보다 작은 범위의 0~n-1으로 표현되는 정수 M이라고 할 때, e라는 어떤 숫자를 이용하여

![보안 10주차 이론-1](images/보안%2010주차%20이론-1.png)

	다음과 같이 암호화
	복호화는 어떤숫자 d를 이용하여
![보안 10주차 이론-2](images/보안%2010주차%20이론-2.png)

	다음과 같이 복호화

- n은 누구나 다 아는 숫자
- 암호화하는 사람은 e를 안다(공개키)
- 복호화하는 사람만 d를 안다(개인키)
- 따라서 PU는 {e, n}, PR은 {d, n}

16)
알고리즘 요구사항
결국
![보안 10주차 이론-3](images/보안%2010주차%20이론-3.png)

이므로, mod n은 여러번 있을 때 한번만 해도 되니까
![보안 10주차 이론-4](images/보안%2010주차%20이론-4.png)

다음과 같은슨 식이 성립해야하고, 모든 M<n인 M에 대해 성립해야한다.

암호화 , 복호화 계산과정이 쉬어야한다.

또 e와 n을 알아도 d를 알 수 없어야 한다.

17)
한번 보자.
앨리스 키쌍 생성
밥이 앨리스에게 암호화하여 메시지를 보내는 상황

-키 생성과정(앨리스)
소수인 p, q 두 수 뽑음, 랜덤하게
p q는 크기가 비슷한 숫자여야함.(비트수가 같아야함)
-> 밀러라빈 같은 알고리즘으로 소수확인후 아니라면 다시 뽑음
공개되는 n값은 n = p x q
이때 Φ(n)값을 구한다.
Φ(n) : n까지의 자연수들 중에 n과 서로소인 것들의 갯수.
	n이 만약 두 소수의 곱으로 주어진다면, Φ(n)  = (p-1)(q-1)이다.

e를 랜덤하게 뽑음
조건. Φ(n)과 e가 서로소여야하고 1<e<Φ(n)이어야함
-> 유클리드 알고리즘으로  gcd(Φ(n) , e)를 계산

이 조건을 	e의 곱셈에 대한 역원(모듈러스를 Φ(n)으로 했을 때)을 구하고,
그것을 d라고 함.
-> 확장 유클리드 알고리즘으로 d 구함
즉 
![보안 10주차 이론-5](images/보안%2010주차%20이론-5.png)

의 관계를 가진다.

이렇게 해서 계산된 
PU = {e, n}
PR = {d, n}

PR은 앨리스만 알고(PR중에서도 d),
PU는 Bob포함 누구나 다안다.

밥이 앨리스의 퍼블릭키를 이용하여 인크립션.
![보안 10주차 이론-6](images/보안%2010주차%20이론-6.png)

M은 플레인텍스트

앨리스는 PR을 가지고 디크립션
![보안 10주차 이론-7](images/보안%2010주차%20이론-7.png)

그런데 이게 될려면,
![보안 10주차 이론-8](images/보안%2010주차%20이론-8.png)

결국 이런 계산을 하고 있는건데, (mod는 여러번하나 한번하나 같다)

e와 d는 
![보안 10주차 이론-9](images/보안%2010주차%20이론-9.png)

이러한 관계였었다.
즉,
![보안 10주차 이론-10](images/보안%2010주차%20이론-10.png)

이렇게 표현할 수 있다. (k는 몰라도 됨. 관심없음)

이 숫자를 대입하면,
![보안 10주차 이론-11](images/보안%2010주차%20이론-11.png)

이 때 오일러 이론에 의해, n과 서로소인 모든 a에 대하여
![보안 10주차 이론-12](images/보안%2010주차%20이론-12.png)

다음과 같은 식을 만족시키게 되는데,
M을 n과 서로소라고 가정하고 전개했다.

따라서 복호화시 M이 잘 도출됨을 증명했다.

사실은 M이 n과 서로소가 아니어도 오일러 이론을 만족하는데, 이는 증명 생략.

따라서 암호화 잘되고, 복호화 잘된다.

한가지. 공격자가 메시지를 복원하거나 공개키로부터 개인키를 알아내는 것을 어렵게하자, 이 부분은 어떻게 할거냐.
뒤쪽에서 언급하겠다.

18)
RSA의 동작 예제

예제일뿐, 실제에서는 이렇게 작은 숫자를 쓰지 않는다

19)
블록사이퍼에서 아주 긴 플레인텍스트가 있을 때 -> 여러개의 블록으로 잘라서 각각 암호화를 적용하였다. AES같은 경우는 블록의 단위가 128비트였고,, 각 블록이 서로 피드백을 줄거냐 안줄거냐 이런걸로 여러가지 mode가 있었다.

RSA에서는 어떻게 할거냐
(b) 예제와 같이 평문을 여러개로 짤라서 숫자로 바꾸고 숫자들을 n보다 작게 블록으로 만들어서 각각 암호화 시키면 되지 않는가? (ECB와 비슷한 접근)
-> 굳이 이렇게 할 필요 없다.

공개키암호로 메시지를 보낼 때 여러블록으로 쪼갤만큼 플레인텍스트가 길다면,
그냥 시메트릭 사이퍼를 사용함.
이 때 키를 안전하게 보내는게 이슈인데,
이 때 공개키알고리즘으로 키를 암호화해서 보내준다.
즉
A는 P를 여러개 블록으로 자룸
K를 가지고 각각 암호화하여 C1만듬
K를 RSA 방식으로  e를 가지고 암호화하여 C2만듬
![보안 10주차 이론-13](images/보안%2010주차%20이론-13.png)

B는 d를 가지고 K를 구함
![보안 10주차 이론-14](images/보안%2010주차%20이론-14.png)

그 K를 가지고 C를 복호화.

이것이 하이브리드 방식. (hybrid encryption)
데이터 용량이 많아지면 암호화를 여러번 해야하는데, 공개키 암호화는 성능이 상대적으로 좋지 않으므로. -> 대량 데이터는 성능이 좋은 대칭암호를 가지고 암호화하고, 키는 공개키암호화를 이용하여 보낸다.
이 때 키를 이렇게 암호화하는 방식을 key encapsulation이라고 부르고
실제 데이터 data encryption은 대칭암호로 한다.

20)
RSA의 전자서명으로써 사용

앨리스 키 생성
아까와 정확히 같은 과정

지금은 앨리스가 밥에게 무언가를 보내려는 상황

 플레인텍스트 M은 그대로 보내고, PR을 가지고 모드연산하여 만든 S를 같이 보냄
![보안 10주차 이론-15](images/보안%2010주차%20이론-15.png)

-> S가 서명이 된다. Signature generation
이는 메세지 복호화 과정과 같다

밥은 서명을 앨리스의 PU을 가지고 확인.
![보안 10주차 이론-16](images/보안%2010주차%20이론-16.png)

-> d는 앨리스만 가지고 있으므로, verifcation시켰을 때 M과 같다면 중간에 오류나 위조가 없었으므로 not repudiation 가능
이는 메세지 암호화 과정과 같다.

21)
인크립셥, 디크립션, 서명생성, 서명확인 과정에서 모두 지수연산을 사용한다.

![보안 10주차 이론-17](images/보안%2010주차%20이론-17.png)

지수가 비교적크더라도 다음과 같은 성질을 사용하면 효율적으로 지수계산을 할 수 있다.

22)
앞에서 이미 했던거지만, 좀 자세하게 다시 설명.

다음 알고리즘은
![보안 10주차 이론-18](images/보안%2010주차%20이론-18.png)

을 계산하는 알고리즘
binary exponentiation 알고리즘
또는 left to right binary exponentiation 알고리즘
또는 square and multiply 알고리즘
이라고 부른다.

b를 비트로 표현.
여기선 b=560이고 비트로는 9자리 이므로 k=9
k=9부터 0 순으로 진행

a는 7, n은 560

f=1 로시작.
비트가 1일때 f에 a값 곱해줌.

1번째 루프
7^1 mod n
f <- (f * f)* 7 mod n = 7

2번째 루프
7^2(비트로 10) mod n
f <- (f * f) mod n = 49

3번째 루프
7^4(비트로 100) mod n
f <- (f * f) mod n = 157

…

5번째 루프
7^17(비트로 10001) mod n
f <- (f * f) * 7 mod n = 160

…

만약에
7^560 mod n을 계산하려면 곱하기 연산이 559번 필요하지만,
위와같은 방법으로 하면 560의 비트수(10) + 비트내의 1의개수(3) 만큼만 하게된다.
-> 즉 곱하기의 회수가 약 log n번이 되고, 최악의경우 모든 비트가 1이라면 2logn.
	평균 적으로는 3/2 log n이라고 볼 수 있다.

이러한 점해서 fast modular exponentiation 알고리즘이라 부른다

**직관적인 이해
7을 559번 곱해서 mod 연산 하기 보다는

7 mod연산 값을 제곱해서 7^2의 mod 연산값으로
7^2 mod 연산 값을 제곱해서 7^4의 mod 연산값으로 만들어가는 방식

23)
그럼에도 불구하고, 이 연산이 AES같은 대칭암호에서 쓰는 연산에 비해 느리다.
왜냐하면 대칭암호에서는 굉장히 큰 수를 다루기 때문.

공개키에서 암호화할 때,
![보안 10주차 이론-19](images/보안%2010주차%20이론-19.png)

이렇게 하는데

예를들어 2048비트 RSA를 쓴다고 가정하면,
e가 2048비트 이므로 평균적으로 3072번정도의 곱셈연산을 하게 된다.

근데 e는 사실 공개키이므로 누구에게나 알려져있으므로 복잡하게 만들 이유가 없다.
-> e를 작게 고정시켜 놓고 쓴다
![보안 10주차 이론-20](images/보안%2010주차%20이론-20.png)

다음과 같은 값이 일반적. (16비트에 1이 맨 앞뒤로 2개인 형태)

* e=3 이나 17같이 더 작으면 안되나?
-> 공개키가 너무 작으면 RSA가 취약해질 수 있다고 알려져있음.

* d도 간단히 해서 계산 빠르게 하면 안되나? -> 안된다. d는 PR이므로 고정시켜놓거나 크기를 줄여버리면 공격자 입장에서 공격하기 쉬워지기 때문에 안전성이 떨어진다.

24)
그럼 Private key에 대해서는 빠르게 연산할 방법이 없나?
있다.

chinese remainder theorem을 쓰면 앞선 지수연산보다 4배정도 빠르게 가능.

내용은 생략.

25)
RSA의 안전성

-Brute force 공격
-> 가능한 모든 키 시도(exhaustive search)
C^d mod n 일때 d는 보통 2048비트이므로
2^2048 개의 모든 가능한 경우의 수를 다 해봐야한다.. -> 사실상 불가

-수학적인 성질을 이용하여 공격
n이 pq의 곱으로 되어있으므로, p와 q 소인수를 찾으려는 노력
-> 알아내게 되면 어떤 일이 벌어지느냐 뒤에서

-RSA의 구조적인 특성을 이용하는 공격

-RSA의 이론상의 안전성과는 별개로 구현 시의 취약점을 이용한 공격

26)
factoring problem

결과적으로보면 n을 p q로 factoring(소인수분해)할 수 있으면 RSA는 깨진다.

왜?

모든 사람은 e, n을 알고 있고 n은 p와 q의 곱임을 알고 있다. p와 q가 무엇인지 모를 뿐

만약에 p q를 구할 수 있으면
![보안 10주차 이론-21](images/보안%2010주차%20이론-21.png)

이거 구할 수 있고,
e도 알고 있으므로
![보안 10주차 이론-22](images/보안%2010주차%20이론-22.png)

d를 구할 수 있다.

따라서 n을 p, q로 소인수분해하려는 노력이 있었다

+) p q안 구하고 Φ(n)을 바로 알아낼 수 있다면, 또는 그냥 e로 부터 d를 바로 알아낼 수 있어도 되지만, 그러한 방법은 현재까지 없음

27)
RSA가 나온이후 소인수분해 알고리즘의 성능이 어떻게 발전되었는가에 대한 표

현재는 대략 1000비트 안쪽정도까지는 가능한 것으로 알려져 있다

28)
팩토링을 어떻게 하느냐. 여러가지 방법이 있지만 가장 효율적이라고 알려져있는 방법
General number field sieve
(special number field sieve는 p q가 특별한 성질을 만족할 때 가능)

x축은 비트수, y축은 연산량. 지금은 1000비트 까지 가능하고 많은 슈퍼컴퓨터를 몇달동안 연산시켜야 가능한 연산량.

시간이 지나면 2048도 깨지겠다.

29)
Chosen Ciphertext Attack(CCA)
RSA 구조를 이용한 공격

![보안 10주차 이론-23](images/보안%2010주차%20이론-23.png)

이 과정을 좀 집중해서 보자

30)
CCA
선택 암호문 공격

공격자가 사이퍼텍스트 여러개를 자기 나름대로 선택해서
private key를 가진 사람에게 해독해달라고 한 뒤 플레인텍스트를 받는 상황 가정.
-> 이 상황이 말이 되나?
예를들어 개인키가 휴대폰에 있다고 했을 때, 화장실 갔을 때 잠깐 소유권을 가진 상황..
또는 요즘 인증을 이용하지 않는 간편결제같은 상황..

공격자는 자기가 지금까지 질문하지 않았던 사이퍼텍스트에 대해, 키를 알고 있지 않음에도 불구하고 플레인텍스트를 복원해낼 수 있으면(1개라도) 성공한다고 가정.

공격자는 C를 복호화한 값을 알고 싶음
-> C’ = C x 2^e 를 복호화 해달라고 요청
![보안 10주차 이론-24](images/보안%2010주차%20이론-24.png)

다음과 같으므로, 2의 역원만 곱하면 원하는 플레인 텍스트 얻을 수 있다.

따라서 이를 방지하기 위해 RSA 회사에서는 OAEP라는 패딩을 RSA구조에 추가한다.
RSA-OAEP

31)
OAEP의 동작 과정

M에 패딩을 넣고 인자를 넣은 해쉬함수의 값을 추가하고,
랜덤한 시드값을 통해 ……

-> 인코딩된 플레인 텍스트인 EM을 만든다.

공격자가 CCA를 위해 싸이퍼텍스트의 임의의 값을 계산하여 보내면
디크립션할 때 EM의 과정을 역으로 올라가는데, 이는 전혀다른 값을 만들어내므로
공격이 유효하지 않다.

추가적으로 seed가 랜덤하게 생성되므로 같은 플레인텍스트도 다른 싸이퍼텍스트로 만들어주는 효과가 있다.

따라서 OAEP는
- 랜더마이즈 효과
- 싸이퍼텍스트에 특정 구조를 주는 효과

가 있어서,

Chosen plain text attack, known plain text attack, CCK 등의 공격들을 잘 막아주다.

RSA-OAEP는 현재 실제로 쓰이는 방법이고,
OAEP가 쓰이지않는 일번적인 RSA는 textbook RSA라고하고 실제로는 잘 쓰이지 않는다.

32)
implementation어택 중 대표적인 어택
side channel attacks
부채널 공격

수학적으로, 구조적으로 얼마나 안전한가와는 무관

알고리즘을 실제로 구현해서 실제로 실행시키는 기계자체를 공격하는 것.
구현시의 부수적인 정보를 활용하여 공격

- 타이밍어택 예를 들어 d의 비트가 1일 때는 제곱과 곱하기, 0일 때는 제곱연산만 일어나는 것을 이용하여 연산의 시간을 추측하여 1이 몇개인지, 0이 몇개인지 추측 -> 전수조사를 할 필요가 없게됨
- 전력소모이용 연산이 일어달때의 전력소모를 분석하여 파형을 얻어서 제곱할때 곱하기 하는 때를 알아냄

![보안 10주차 이론-25](images/보안%2010주차%20이론-25.png)

- 전자기파이용 위와 마찬가지
- 클라우드 환경에서도 캐시를 이용하여 조작가능

막는 방법
- 비트가 어떻든 무조건 제곱, 곱하기 두 번다한다. -> 시간적인 오버헤드 존재 -> 또 통계적으로 분석하면 깨질 수 있기 때문에 완전한 해결책은 아님
- 랜더마이즈, 블라인딩 방법

33)
implementation 어택 중 좀 더 공격적인 어택

Fault-Base Attack
정상적인 연산을 시켜서 정상적이 결과를 얻고
연산이 수행되는 와중에 의도적으로 에러가 발생하도록 유도하여 원하는 결과를 얻어내는 방법을 이용
사이드 채널 공격보다 더 어렵다고 알려져있음

34)
공개키에 관한 오해들

- 공개키 알고리즘이 symmetric encryption보다 더 안전하다? RSA는 2048비트 키를 쓰고, AES는 128비트(192 ..)짜리 키를 쓰니까? -> 아니다. 물론 전수공격을 하면 RSA의 경우의 수가 더 많지만, 공격자는 그렇게 공격하지 않는다. 공격하는 방식 자체가 다르기 때문에 그렇게 얘기할 수 없다.
- 공개키 알고리즘이 symmetric encryption을 완전히 대체할 수 있다?  -> 아니다. 성능적인 측면에 있어서 symmetric encryption이 더 좋기 때문에, 대용량 데이터 암호화하는데 symmetric encryption을 사용하고 그 키를 공유하는 문제는 공개키를 사용하는 hybrid 형태로 쓰는게 일반적
- symmetric encryption의 키 공유문제를 해결하기 위해 나온게 공개키암호인데, 공개키 사용하면 키 분배 문제가 완벽하게 해결된다. -> 아니다. 상대적으로 symmetric encryption에 비해서 키 공유가 조금 낫다는 거지 그 문제가 근본적으로 해결되지는 않는다. 대칭 암호에서의 키 분배는 confidentiality가 보장된 상태에서 분배되어야하고, 공개 키 암호에서는 authentication과 integrirty가 보장된 상태에서 분배되어야한다.-> 즉 키가 조작되거나, 전혀 다른사람의 공개키가 이 사람의 공개키인 것처럼 분배되면 문제가 생길 수 있다. -> 이러한 문제 때문에 공개키인증서 라는게 나오게 되었고, 정부에서 공인한 절차로 만든게 우리나라의 공인인증서 이다. 이 부분은 나중에 뒷부분에서 자세히 다루겠다.

35)
요약

