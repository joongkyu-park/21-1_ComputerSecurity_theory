# 보안 4주차 이론

지난번 복습 퀴즈.

- 엑세스 컨트롤 매트릭스를 압축해서 표현하는 방법중, 객체위주로, 이 객체에는 어떤 접근권한이 있다 표현하는 방법이름? ACL
- 주체위주로? CL
- ACL 자주 쓰이는 예시? 윈도우 등
- CL 자주 쓰이는 예시? 안드로이드 앱커미션 등
- 사용자 인증하는 방법(사용자계열) 3가지? User knows(사용자가 알고 있는 정보) User has(사용자가 가지고 있는 정보) 사용자 자체에 대한 특성 그리고 각각 예시

정수론 내용
- 모듈러 리덕션 11 mod 7 뜻? 11을 7로 나누었을때 나머지 값(4) -11 mod 7? 답 3 (나머지는 0이상이므로 -> 그래야 몫과 나머지가 유일해짐)
- 유클리드 알고리즘 간단하게 설명?
- extended 유클리드 설명?..

==================================================
23)
Prime numbers
1과 자기자신 이외의 약수가 없는 숫자
다른 숫자들의 곱의 형태로 표현할 수 없는 숫자
-> 정수론에서 굉장히 중요한 역할.(number theory)

소인수분해. 유일하게 표현할 수 있다.

24)
페르마 이론

p(소수), a -> p로 나뉘지않음, 즉 a와 p는 서로소
이 때 
![보안 4주차 이론](images/보안%204주차%20이론.png)

즉
![보안 4주차 이론-1](images/보안%204주차%20이론-1.png)

예시
![보안 4주차 이론-2](images/보안%204주차%20이론-2.png)

증명은 이따 시간나면 하겠음

이 때 이 식의 양쪽에 a를 곱하면
![보안 4주차 이론-3](images/보안%204주차%20이론-3.png)

이 때는 제약조건 필요없음.
왜냐하면,
![보안 4주차 이론-4](images/보안%204주차%20이론-4.png)

25)
오일러 totient function ø(n)
n보다 같거나작은 양의정수중에 서로소인 것들의 갯수

특별한 경우 2가지
1. n이 소수인경우
2. n = pq 인경우 (p, q  둘다 소수)

![보안 4주차 이론-5](images/보안%204주차%20이론-5.png)

증명해보자.
1. 이건 자명. n이면 1~n-1까지 다 서로소니까
2. if) n = 3*5 n과 서로소가 안될려면, 3의배수이거나 5의배수이면됨 1~15부터, 3의배수? 3 6 9 12 15 (5개) 5의배수? 5 10 15 (3개) 남는거 -> 8개.  전체 15개중 -3(5의배수) - 5(3의배수) +1 (15가 2번지워지니까) = 8  일반화. n = pq n - q - p + 1 = (p-1)(q-1) (인수분해)

26)
오일러 theorem
![보안 4주차 이론-6](images/보안%204주차%20이론-6.png)

양쪽에 a를 곱해주면
![보안 4주차 이론-7](images/보안%204주차%20이론-7.png)

-> 이 식 역시 서로소 조건이 아닌 경우에도 성립하게 됨

페르마 theorem이 오일러 theroem의 특수한 형태라고 볼 수 있음

27)
primality test
소수인지 아닌지 테스트 하겠다

암호에서 쓰는 소수는 굉장히 큰 소수이다. (비트로 따지면 1000비트..10진수로 약 300자리..)
그래서 소수를 찾는게 쉬운 작업이아므로,
임의의 난수를 뽑은후, 그게 소수인지 테스트 -> 아니면 버리고 다시 뽑음

- 트라비얼 테스트

ex) 37이 소수인가?
37아래의 모든 소수로 나눠봤을때, 한번도 안나눠지면 -> 소수이다.
근데 사실상 자기자신에 도달할때까지 다해볼필요는 없고, 제곱근 값까지만 해보면된다.
왜냐하면 나누어지게 된다면 큰소수곱해지면 그에 대응하는 작은소수가 곱해질 것이니까.
-> 근데 300자리의 숫자를 이렇게 하기엔 힘들다

- 페르마 테스트 페르마테스트가 성립하지 않는다 -> 전제가 성립하지않는다 -> p는 소수가 아니다 즉,

![보안 4주차 이론-8](images/보안%204주차%20이론-8.png)

이러한 a를 하나도 찾는다 -> p가 소수가 아니라는 증거를 찾는 것.

- NSR test(nontrivial square root) 소수인지 아닌지 테스트할 숫자는 홀수로가정(짝수는 2밖에없으므로) 1과 -1 이외에 x^2=1이 되는게 또있다(?) -> 소수아니다 스샷참고..

-> 우리는 페르마테스트, nsr테스트를 사용할 것 (트라비얼 테스트는 성능이 넘 안조음)

28)
***
책에 있는 내용이 똑같은데 이해하기 어려워서 별도 자료로 설명

밀러-라빈 알고리즘

input n이 프라임넘버인지 아닌지 테스트 (n은 홀수)

True -> 합성수인 증거 찾았다 = 소수 아니다

예시2개.

NSR에서도, 페르마에서도 True가 아니면 (True이면 합성수인증거 찾았다, 끝)
False를 리턴 ->이 뜻은 합성수인지 아닌지 잘 모르겠다는 뜻
-> 다른 a가지고 합성수인 증거를 찾으려고 루프돌림. -> s번 루프돌렸는데 True가 한번도 안나왔다
-> 아쉽지만, 결론을 소수라고 냄 -> almost sure임. 틀릴수도있음(하지만 틀릴확률이 얼마 안된다는게 중요)
*합성수인경우에는 100프로임

한 번 루프를 돌때 true을 리턴받지못하면, 소수임이 틀릴확률이 1/2(1/2보다 좀작음)
2번 루프면 1/2의 제곱..
s번 루프… 틀릴확률이 1/2의 s제곱보다 작은 오류확률인데 s=100이면 굉장히 작은수다.
따라서.. 틀릴확률을 거의 0이라고 본다

=> 랜덤한 요소가 개입되는 알고리즘, randomized alogrithm
이 랜더마이즈 알고리즘엔 2개의 계열이 있음
![보안 4주차 이론-9](images/보안%204주차%20이론-9.png)

이 알고리즘은 몬테카를로 알고리즘
특징은 시간은 정해져있음(bounded). 그 시간에 답이나올거냐 안나올거냐가 확률적

라스베거스 알고리즘은, 정확한 답을 내놓지만 언제 끝날지는 모르는 알고리즘.

+) gcd 굳이..? 아래에서 할필요가 없?.. 마지막 스샷참고.. 어쩌구

다시 돌아와서
29)
aks 알고리즘은 정확하게 찾을 수 있음 -> 근데 너무 느려서 거의 안씀

30)
보통 하이브리드로 씀. trial division + MR/Fermat

ex) n=3579371591
trial division으로 작은 넘버들을 나눠보고 시작하자..
3,5,7,1,,13,17

3의 배수를 지운다는 사실은, 1/3 정도를 필터링할 수 있음
5의 배수 -> 1/5 정도 필터링..
..
=> 적당히 해보면 꽤많이 지울수 있다.
따라서 trial division으로 먼저 필터링 후 밀러라빈으로 테스트~	

trial division가 느린이유는 단일 숫자에 대해서는 빠른데, 모든 숫자들을 다해보는게 느린것..

이런 소수판별은 openssl(오픈패키지) 같은 곳에서 주로 사용한다.

예전 : SSL : secure socket layer
최근 : TLS : transport layer security -> Transport층 즉 TCP에서 보호하겠다

이거 대표적인게 https://
http : 프로토콜로 웹사이트로 보겠다
s : 트랜스포트 계층에 TLS가 깔린채로 보겠다.

31)
정수의 거듭제곱.

싸이클이생김. modulo 19이면
17제곱까지는 싸이클이 안생기고, 18(19-1)제곱때 서로소이면(?) 값이 1이되므로 19제곱은 1에다가 같은수 곱하는거니까 똑같음.

여기서 2와 같은수를 generator  = primitive element라고 한다. -> 1~18의 수를 다 생성해냄

3은 generator인가? 맞다.
4는 아님 -> 18보다 짧은 사이클이됨.

*generator와 아닌 숫자의 차이는, generator는 18제곱해야 1이나오고 generator는 그전에 1이나옴. 근데 얘도 역시 18제곱때는 1이 되어야함
	=> 이렇게 되려면 싸이클의 길이가 18의 약수여야함.(6, 3, 9..)

32)
discrete logaritihm (이산 대수)

예를들어
![보안 4주차 이론-10](images/보안%204주차%20이론-10.png)

이 때의 x를 예측하기란 쉽지않다..

왜냐하면 31페이지의 테이블에서 보면, 숫자들의 관계가 단조증가도 아니고 규칙이 딱히 없기때문..

공개키암호를 배울때 (대표적으로 RSA, Diffie-Hellman, 뒷장에서 나올것)
-> 수학적으로 어려운 문제에 기반해서 설계를 함.
-> 그 문제가 깨지면 암호도 같이 깨지도록
-> 이러한 알고리즘들이 2가지에 기반함
1. discrete logaritihm 
2. Integer Factorization  -> RSA가 이거 사용

33)
(3)의 숫자를 주고 아래의 2가지 요소로 소인수분해해라 ->> 이건…. 쉽지않다. (거의 10년걸림 컴퓨터로)
2가지 요소를 곱해서 (3)을 구하는건 쉽지만.

->근데 RSA같은경우 1000bit, 2000bit 정도의 암호를 사용하니까 굉장히…. 어렵다

34)
요약.

