# 14주차 이론 - 13장 전자서명(2)

2)
컨텐츠

3)
NIST의 전자서명 표준 - DSA

4)
Schnorr vs. DSA

Schorr Sig.
서명 scheme
키쌍이 존재 : 개인키 a, a를 지수로 올려서 만드는 공개키(특이하게 -a 제곱을했다)

지수에 대한 연산을 할 때
원소개수가 p-1개인 그룹을 쓰는 대신에
p-1의 약수인 q개의 원소를 갖는 서브그룹을 가지고 다루었다.
지수에 mod q연산을 하고 mod p를해도 서로 같다.
지난시간 예)
p = 19고 2같은 숫자가 generater라서
2^1 … 2^18을 해야 1로 돌아오는데,
만약에 8같은 원소에서 시작하면,
8^1, 8^2, .. ,8^6에서 1로 돌아온다 -> 원소 6개만에 1로 돌아오는 싸이클이 생긴다
이런 것을 크기 6 짜리인 서브그룹이라, 얘기했었다
따러서 알파를 2같은 전체그룹의 제네레이터가 아닌, 8같은 서브그룹의 제네레이터  가지고 하겠다. 지금 같은 예에서는 q가 6에 해당하는것.
그래서 6보다 큰 지수는 의미가 없다는 뜻. 6제곱하면 1이 되버리니까.
그래서 지수에 mod q하면 계산결과가 같아지고, 모든 지수들은 mod q단위로 연산을 했었다.

메세지 M이 주어졌을때 개인이 a를 가지고 어떻게 서명을하냐
서브그룹 제네레이터 알파 (위에서 8같은)
랜덤한 k를 뽑아서 감마 계산
메세지와 감마를 붙여서 해쉬를 돌려 r 얻음
r과 개인키 a와 k를 이용해서 mod q 연산을 이용해서 y값 얻음
(verification 할 때 y가 지수로 올라가기 때문에 mod q 연산을 해준다.)
이렇게해서 계산된 r, y의 순서쌍이 서명이 된다.

이 M,(r,y) 쌍을 어떻게 확인하느냐
제네레이터 알파에 y를 지수로, 퍼블릭키v에 r을 올리고 곱한후 mod p -> 감마 프라임 (이 계산은 누구나 할 수 있음)
그걸 메세지랑 붙여서 해시함수 돌리면 r값이 나오는데, 위의 r과 같은지 확인한다.

원래 쉬너 identification에서는 verification의 1번과 2번 과정이 반대였었는데, signature는 이런식으로 구성했었다.

한편 DSA
기호가 조금 씩 달라져서 정정
여기서의 g가 제너레이터 알파
여기서의 x가 개인키 a
여기선 공개키 제곱할 때 -x제곱을 하는게아니라 그냥 x제곱을 한다.
여기서의 공개키는 y이고 , y = g^x mod p 

먼저 r = (g^k mod p ) mod q (q가 더 작아서 서명의 크기를 줄이는 효과가 있다)
메세지만 넣고 해쉬돌리고,
여기서의 s가 쉬너에서의 y인데,
다음과 같이 s를 구한다
![14주차 이론 - 13장 전자서명(2)](images/14주차%20이론%20-%2013장%20전자서명(2).png)

계산과정에서 k의 곱셈의 역원을 구한다

이렇게 해서 계산된 r, s의 순서쌍을 서명을 한다.

서명확인 할 때는,
메세지와 서명 쌍이 왔을 때
확인하는 측에서는 공개키를 알텐데, 공개키는 y= g^x mod p 이다.
메세지를 먼저 해쉬를 하고, w를 곱한다.
w는
![14주차 이론 - 13장 전자서명(2)-1](images/14주차%20이론%20-%2013장%20전자서명(2)-1.png)

서명의 두번째 값인 s’의 곱셈의 역원 계산을 한것.

그 w와 해쉬된 M을 곱한게 u1,
첫번째 서명 r’과 w을 곱한게 u2.

그리고 v를 계산할 때 u1와 u2를 지수로 올려서 계산한다. (쉬너에서 감마’을 구하는것과 비슷한 구조)

정상적으로 서명확인이 된다는 것을 보자

v를 구하는 과정에서,
![14주차 이론 - 13장 전자서명(2)-2](images/14주차%20이론%20-%2013장%20전자서명(2)-2.png)

쉬너 시그니처랑 모양이 비슷한다.

기본적으로 디스크리트 로그에 기반,
암호화 방식에서 공개키, 개인키의 역할을 바꾼 그런 형식이아니라
identification에서 시작해서 약간 바뀌게된 그런 형식이겠다.
즉, 암호화역할은 못하고 서명역할만 가능

5)
DSA를 타원곡선으로 바꾸기
ECDSA

디스크리트 로그와 타원곡선상의 디스크리트 로그를 다시보자.
![14주차 이론 - 13장 전자서명(2)-3](images/14주차%20이론%20-%2013장%20전자서명(2)-3.png)

디스크리트 로그에서 지수에 해당하는게, 타원에서는 상수배(즉 각각 곱셈과 덧셈)

DSA
개인키 x로 공개키 y를 만들었고(g^x = y)

타원곡선에서는
개인키 d, G를 d배한 Q가 공개키

서명생성과정
DSA에서는
랜덤한 k를 만들어서 g에 k제곱 후
mod p 후 mod q 한것이 r

타원에서는
G에 k배한 (x, y)에서 x만 취해서 mod n한 것이 r

메세지 해쉬 후 s를 만드는 과정은 똑같다.

그렇게 해서 만든 r, s를 서명으로 한다.

ECDSA에서는 서명확인 어떻게하나

메세지를 우선 해쉬해서 e
s의 곱셈역원을 w
똑같이 u1, u2를 구해서
DSA에선 지수로 올렸던것을 여기에서는 G와 Q의 계수로

정상적으로 계산이 된다면, 이런식으로 계산된 X라는 것이 kG와 같아야한다.
따라서 X의 x좌표만 떼서 mod n한 것과 kG의 x좌표떼서 mod n한 r과 같아야한다.

서명확인할 때 M, r, s, 공개키 Q 를 이용했다.

6)
RSA-PSS

RSA를 텍스트북 버전으로 구현하면 서명 안전성에 문제가 생긴다고 했다.

이것은 RSA회사에서 만든방법인데, 텍스트북 버전을 그대로 쓰는게 아니라
OAEP 패딩을 붙였던것처럼, 서명도 그때그때 바뀌게 만들어준다.

![14주차 이론 - 13장 전자서명(2)-4](images/14주차%20이론%20-%2013장%20전자서명(2)-4.png)

이러할 때 똑같은 메세지에 대해서는 똑같은 서명이 나오게 된다.
-> 이런거 별로 안좋다

따라서 랜더마이즈된 정보를 집어넣어서 확률적으로 그때그때 다른 서명값이 나오도록 바꾸어준다
이게 표준.

7)
간단하게 보자.
RSA-PSS의 목적 : 같은 메세지가 들어가도 다른 서명이 나오도록 하는 것

salt가 매번바뀌는 랜덤값
padding1은 누구나 같은 값을 쓰는 상수
MGF도 본질적으로 해쉬함수.
padding2도 미리 정해진값
…
쭉 결과로 나온 EM^d mod n 으로 서명을 한다.

서명하는 쪽에서는 저값에 e제곱을하여 EM을 복원시키고, 그게 이제 맞는 형태인지 확인한다.

…

8)
서머리

DSA나 쉬너같은 계열은 암호화로 쓰지 못하고, 서명용으로만 사용할 수 있다. 

