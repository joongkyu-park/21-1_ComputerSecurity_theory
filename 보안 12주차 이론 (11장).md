# 보안 12주차 이론 (11장)

11장. Crpytographic  hash functions

2)
- 해쉬함수의 개념과 정의
- 5가지 응용 예
- 안전정 요구조건들, 공격사례
- secure 해쉬 알고리즘

3)
해쉬 함수의 정의
해쉬 함수는 길이가 가변적인 데이터 M을 만들어서
정해진 크기의 hash value를 결과로 낸다.
주로 data integrity용도로 사용

암호학적으로 사용되는 해쉬함수는 2가지 조건을 만족해야함(일종의 간단한 안전성 요구조건)

- one way property M을주면 h를 구하는건 쉬운데, h를 알아도 M을 알아내는건 어려워야함
- collision-free property 서로다른 M1, M2가 같은 h가 나오는 경우(collision)가 없어야함(매우적어야함)

4)
그림으로 표현

메세지나 데이터블록 M(가변적)을 입력으로 받으면
해쉬함수가 고정된 길이의 h를 낸다.

5)
해쉬를 그냥 Integrity 용도로 쓰면 어떻게될까? (MAC이 아니라)
전송되는 도중에 데이터가 변조가 되었는지 안되었는지 확인하는게 integrity

앨리스는 데이터를 해쉬함수에 넣어서 뒤에 붙인다음에 전송.
밥은 그걸 받아서 데이터부분만 짤라서 해쉬함수에 넣은다음 뒷부분과 비교 -> 같으면 변조없었다고 판단

그런데 중간에 다스가 껴서(맨인더 미들어택) 다음과같은 상황을 만든다면, 데이터자체를 변조하는거기때문에 밥 입장에서는 해쉬함수를 돌려서 비교했을 때 같은 값이 나오긴하지만, 중간에 변조가 일어난 데이터임.

뭐가 문제일가. 다스가 공격을 할 수 있었던 이유.
변조된 데이터에 대해 자기 나름대로 해시값을 쉽게 계산할 수 있었기 때문
->막으려면 해쉬를 쉽게 계산하지 못하게

6)
MAC(Message Authentication Code)
을 keyed hash function이라고도 부름. CBC같은 블록사이퍼의 MAC도 마찬가지.

해쉬함수인데 데이터만 가지고 해쉬를 하는게아니라, 키를 넣고 해쉬함수를 넣는다.
그 키는 수신자와 송신자만 공유하는 비밀키. 그 키를 이용하여 해쉬값을 만들겠다.

인풋으로 시크릿 키, 데이터블록
아웃픗으로 hash value인데 키가 작용됨. 이걸 MAC으로 활용할 수 있다.

공격자는 키가 없기때문에 MAC값을 변조할 수 가 없다.

7)
그림으로 한번 보자
(c)를 가장 많이쓰기때문에 (c)만 설명

|| 는 concatenation 기호. 뒤에다 붙인다.

즉 메세지에 비트스트링으로 키를 붙인다. 그거를 해쉬함수에 넣는다.
그거를 원래 메시지 뒤에 붙인다. => M || h
*지금 메세지 숨기는게 목적이 아니다*

받은 메세지부분만 자기가 알고있는 키값과 concatenation해서 해쉬함수돌려서 받은 해쉬값과 비교.

integrity : 중간에 변조가 없었음을 알 수 있다.
authentication : 시크릿 키를 가지고 있는 송신자가 보낸것이므로 인증가능.

+)
CBC도 MAC을 이용했었는데 나름 압축한게 되겠다
왜냐하면
![보안 12주차 이론 (11장)](images/보안%2012주차%20이론%20(11장).png)

이와 같은 과정에서 나머지 싸이퍼 블록들은 다 버리고 c3만 원래 메세지 뒤에 붙이기때문에, 메세지길이가 얼마던 인증에 사용되는 블록(여기선 c3)는 동일하므로..

8)
해쉬의 2번째 응용. 전자서명

여기서 해쉬의 역할은 MAC과 비슷하다.

어떤 메시지에 대해서 integrity, authentication, not repudiation까지 제공하기를 원할 때,  보내는 사람이 자기의 개인키를 이용해서 메세지의 해쉬값에 서명을한다(인크립트를 한다)
보내는 사람의 퍼블릭키를 아는사람은, 메세지의 무결성과 누가보냈는지 알 수 있다.

만약 메세지를 변조하고자하는 공격자는 송신자의 개인키를 알아야한다.

전자서명은 message authentication보다 더 많은 것을 할 수 있다 -> not repudiation

9)
전자서명에서 해쉬가 어떻게 사용되는지

RSA의 경우 복습
공개키 e,n의 쌍
개인키 d
모든연산은 mod n으로. 생략하겠다
![보안 12주차 이론 (11장)-1](images/보안%2012주차%20이론%20(11장)-1.png)

이러한 과정이었다.
이게 mod 연산이기 때문에 M<n이라는 조건이 있다.
그럼 만약에 서명으로 확인하야할 메세지가 길이가 굉장히 길다면?
블록사이퍼처럼 블록으로 따로 따로 할것이냐?
그럴필요없다.
해쉬함수를 이용하면 일정한 길이가 나오기때문에, 해쉬가 충분히 긴 길이로 나온다면 서명의 안전성에 문제가 되지 않는다.
따라서 M에 대신에 M이들어가는 모든 자리에 해쉬값 H(M)으로 서명을 대신할 수 있다.
![보안 12주차 이론 (11장)-2](images/보안%2012주차%20이론%20(11장)-2.png)

이 때 의 E는 인크립션이아닌 서명만드는것
H(M)에 d제곱(이게 서명)을 해서 M에 붙임.
수신자는 H(M)의 d제곱을 e제곱하여 H(M)과 비교.

이는 메세지가 길 때 대응하기 위한것.

만약에 메세지 내용까지도 숨기고 싶다.
서명과 암호화 동시에 진행
메세지가 긴 대용량데이터를 전송하는 상황이기 때문에 하이브리드 인크립션을 써서
암호화를 위한 공개키는 디피헬만이든, rsa의 인캡슐레이션이든 키를 전달하는 방법이든 세션키를 만들어 놓고, 그 세션키를 가지고 데이터를 블록사이퍼같은걸로 인크립션하는 방법을 쓰는게 좋다고 했다.

![보안 12주차 이론 (11장)-3](images/보안%2012주차%20이론%20(11장)-3.png)

따라서 앞부분은 서명을 생성하는 부분과 똑같고, 그 전체를 인크립션.
앞의 E는 서명, 뒤의 E는 인크립션
마치 문서에 서명을 한후 봉투에 넣는 것.

10)
세번째 해시함수의 용도
one-way password file

사용자가 서버에 회원가입을하고 패스워드를 넣을때,
서버는 DB에 패스워드를 그냥 저장하는게 아니라 해쉬를 거쳐서 해쉬값을 저장한다.

해쉬함수는 입력이 같으면 결과도 같은 함수이다.
해쉬함수는 잘설계되었다면, 2가지 성질을 만족해야한다
-one-way : 인풋으로부터 해시값만드는 건 쉽지만, 역은 어렵다
-collision free : 우연히도 다른 인풋이 같은 해쉬값을 가지는 경우가 거의 없다
	-> 만약 다른 패스워드가 우연히 같은 해시값을 가지면, 서로 인증이 된다.

여기서도 문제가 있다.

공격자가 사용자의 패스워드의 해시값을 알아냈다.
역방향으로 진행할 수 없으니까 순방향으로 뚫는다.
만약 비밀번호가 5자리라면, 공격자는 브루트포스(전수조사)공격을 할 것이다.
그런데 비밀번호의 경우 사용자들이 자주 사용하는 비밀번호의 통계가 존재한다.
그래서 시스템을 공격하기전에, 이러한 비밀번호와 해쉬값의 조합을 미리 공격자는 가지고 있는다. -> offline dictionary attack
그래서 다른 사람의 해쉬값을 보고, 미리 저장해두었던 해시값과 동일한게 존재하면 비밀번호를 알아낼 수 있는 방식.

이를 방지? 어렵게? 하기위해 ’salt’사용
비밀번호에 salt를 ||하여 해쉬함수를 돌려 해쉬값을 저장.
이 salt같은 사용자마다 다 다름.
그래서 공격자가 만약 aabbb라는 비밀번호를 안다고했을때
아까는 H(aabbb)만 알면됐는데, 솔트가 들어가면(5자리 숫자라고가정)
H(aabbb || 11111),
H(aabbb || 11112)…
이걸 모두 다해봐야한다. 좀 더 공격하기 어렵게 만듬

11)
4번째 방법.
intrusion과 virus detection에 사용

파일이나 이미지같은것도 비트시퀀스로 바꿀 수 있으니까 해쉬함수에 넣을 수 있다.
파일을 해쉬함수돌려서 해쉬값으로 저장한다고 했을때,
원래의 파일이 변경되었다면 해쉬값 비교를 통해 변조여부를 시스템이 알려줄 수 있다.
그러나 공격자가 해쉬함수까지 바꾸어서 공격해버리면 뚫리는건 마찬가지. 그래서 해쉬값을 쉽게 찾을 수 없는 곳에 잘 보관해야한다는 점이 있는데..,

secure boot
부트이미지를 해쉬함수를 돌려 해쉬값을 만듬
그거를 제조사에서 가지고 있는 private키로 서명을 함. (마치 S = M^d 했던거처럼)
그리고 그거를 풀 때는 ROM(덮어쓰기 못한다는 특징)에 공개키를 저장해놓아서 그 공개키로 푼다. (마치 M = S^e)
그렇다면 부트이미지나 해쉬함수가 공격되었다고 해도 ROM에 저장된 공개키는 변경을 할 수 없으므로 서명으로 공격여부 확인이 가능하다.

12)
5번째 응용
PRF이나 PRNF 용도로도 사용된다.
난수발생에 카운터모드라던가 해시함수라던가 H-MAC이라던가 여러개 사용했었는데
이 해시함수를 가장 많이 일반적으로 사용

13)
해쉬함수의 요구조건

Preimage 찾기가 어려워야한다(one-way)
h = H(x)일 때, x를 h의 preimage라고 한다. 데이터블록을 의미하겠다.
h를 알아도 preimage를 찾기가 어려워야한다.

Collision(collision이 잘 안일어나게, collision-free)
x!=y이면 H(x)=H(y)인 상황이 없어야한다.

MAC에서의 응용
만약 one-way성질이 깨지면, H(D||S) = h에서 S를 알 수 있는거고,, 그때부터는 뭐 다 할 수 있으니 끝난거지

collision free가 깨지면 데이터가 다른데도 같은 h값이 만들어 질 수 있으므로, 수신자는 h가 같은 값이니까 데이터의 변조가 없었다고 판단하는데, 그게 공격자가 변조한 데이터일 수 있다.
 
![보안 12주차 이론 (11장)-4](images/보안%2012주차%20이론%20(11장)-4.png)

전자서명의 경우, one-way는 상관이 없다.
전자서명을 만드는데 사용되는 해쉬의 대상이 데이터인데, 데이터는 공개하는거니까.

collision free는 문제가 있다.
데이터에 사인을 하는데, 변조된 데이터를 넣고 다른 사인을해도 같은 해쉬값이나오면 안되니까

패스워드에서 응용
one way, collision free 둘다중요. 아까설명함

시스템의 integrity. collision free가 중요하다.
시스템의 이미지가 변경되었는데 해쉬값이 똑같다. 그럼문제가 되는거니까

PRNG
Preimage가 중요하겠다.
시드에서부터 생성되는건데, 시드가 밝혀지면 안되는거니까

14)
그런 성질들을 만족하기위해 해쉬함수를 어떻게 만들어야할까

2가지의 안전하지 않는 해쉬함수의 예

상황
인풋을 n비트의 블락들로 잘라서
iterative fasion으로 각 블락들을 해쉬함수처리

1. 모든 블락을 비트단위로 XOR

2. 다음번 블록을 다룰 때는 1비트르를 circular shift하여 XOR

15)
그림으로 보자
n=16인 사례.

긴 데이터를 2바이트 단위로 짜른것.

16비트로 쫙 쌓아서, 각 컬럼의 값을 모두 XOR시킴.

비트 로테이션시키는 거는 현재 블럭 기준 다음 블럭을 모두 1비트씩 shift시킨것. 그러고  XOR시킴.

이렇게 하면 데이터가 아무리 맞아도 16비트로 압축시킬 수 있을 것.

해쉬함수는 맞지만, 암호의 용도로 쓰려면 2가지 성질이 만족했어야했다.

one-way성질 만족X
결과 비트로 이전비트를 만들 수 있기때문(그렇대그냥)

collision-free도 만족X.
간단하게 예만 들어도 같은 컬럼에 비트 위치바꾸어도 해쉬값같자나. 데이터는 달라졌는데.

이렇게 만들면 암호학적 용도로 안된다!

16)
방금같은 해쉬함수들은 공격이 자명했다.

보통 해쉬함수공격은 2가지 방법으로 한다

-Brute Force Attack
막 공격함. 브루트 포스로 콜리젼을 찾는다.
이런 식에 공격에 견디라면 output 해쉬값이 길면 길수록 좋다.
따라서 공격의 복잡도는 해쉬값의 길이에만 온전히 의존.
만약 해쉬값 길이가 2^10이면, 1025개의 랜덤인풋을 돌리면 무조건 콜리젼 하나는 나오니까

-Cryptanalysis
해쉬알고리즘은 누구나 알 수 있으므로, 그 알고리즘을 분석을 하는것.
콜리젼이 발생할 여지가 있을 지없을지. 그런것들을 분석하여 공격

17)
m-bit의 출력을 주는 해쉬함수가 있다. -> 2^m개
충돌이 일어나게 하려면 2^m+1개의 인풋만 넣으면 충돌발생시킬 수 있음

그러나 실제로는 이거보다 훨씬 작은 인풋만 넣어도 충돌을 발생시킬 수 있다
대략 2^(m/2)개만 해보면
그러니까 m이 128비트라면, 2^128+1개가 아니라 2^64개만 해봐도 된다.
이를 ‘birthday paradox’라고 부른다.
![보안 12주차 이론 (11장)-5](images/보안%2012주차%20이론%20(11장)-5.png)

  학교 반에 50명이 있다고 했을때, 생일이 같을 사람이 있을 확률은?
-> 거의 100프로다. 왜냐

1번째학생 -> 다를 확률 1
2번째 -> 다를 확률 364/365
3번째 -> 다를 확률 363/365
…
그렇다면
모든 학생의 생일이 다를 확률은 1 * 364/365 * 363/365 * ….
일텐데 이 값이 1/2보다 작아지는 k번째,
즉 k번째가 되면 생일이 같은 사람이 나올 확률이 1/2이 넘어가는건데
그 k가 23이다.
따라서 50명이면 저 값이 거의 0에 가깝고 거의 같은 생일자가 존재한다.

마찬가지로 비트도
![보안 12주차 이론 (11장)-6](images/보안%2012주차%20이론%20(11장)-6.png)

이렇게 쭉 곱했을 때 1/2보다 작아지는 지점이 2^(m/2) 지점이라는 것

직관과 달라서 paradox라고 부름

이건 완벽히 만들어진 해시함수라도 발생할 수 밖에 없음.

따라서 해쉬값의 길이가 작으면 다음과같은일이 발생할 수 있음.
예)
A가 B에게 계약에 대한 서명을 해야하는 상황
100만원 지급인데, B가 공격자. 100억으로 바꾸려함

원래 메세지내용 x에 대해서, 뜻은 같지만 조끔식 variation이 있는 x’을 2^(m/2)개 생성
그 메세지와 해시값을 저장
그리고 변조하고싶은 내용 y에 대해, 뜻은 마찬가지로 y’를 생성.
이 때 H(x’) = H(y’)인 것이 있으면 성공.
A는 x’에 서명을 하지만 결과적으로 y’에 서명한 꼴이 된것

18)
실제 예를 보자.
72비트의 해시값 인경우. -> 2^38개의 variation을 생각해보는 것.
같은 의미의 내용을, 총 38개의 단어 변조를 두어 총 2^38개의 경우의 수를 만들어서 해시값을 다 만들어 보는 것.
이런 뜻임

19)
다시 설명.
본질적으로 100만원을 준다는 내용은 같지만, 단어를 조금씩 변조를 주어 2^(m/2)개의 경우의 수를 만들어 내는것. 위의 예에서 2^38개

그리고 100억원으로 바꾼다음에 해시값을 만들어서 같은게 있는지 확인.
없으면 100억원을 줌 -> 송금함 이런식으로 바꿔서 다시 해시해본다음에 같은게 있는지 또 없으면 100억원을 지급 .. 이런식으로 변조
…
나올 때 까지함. -> 충돌이 생길확률이 굉장히 높다는 것.

이거 어떻게 막느냐.
2^38라는 숫자자체를 늘려야해서, 비트수를 늘리는게 중요하다.

요즘에는 256비트나 512비트 해시를 많이 쓴다.
위에서 본것처럼 512비트를 쓴다는것은 256비트의 안정성을 갖는다는 뜻이다.

20)
여기서 혼동하면 안되는것.
해쉬값이 길다고 안전해지는게아니라, 해쉬함수의 구조적인 취약점(앞의 XOR)이 없이 해쉬값이 길어야함
그래서 해쉬함수를 잘 설계해야한다.

NIST에서 안전한 해쉬함수를 만드는 알고리즘을 표준화
SHA (Secure Hash Algorithm)

SHA-1이 표준화되었다가, 최근에 깨짐

구조는 비슷하지만 키값을 더 늘린 SHA-2가 나옴

21)
SHA-2중에 512비트 아웃풋을 주는 SHA-512라는 해시함수의 대략적인 모습.
그냥 블록함수랑 비슷하게 생겼구나 정도만

22)
해쉬함수의 라운드의 내부구조가 이렇게 생겼구나.
라운드에서 사용되는 연산
+ : 그냥 정수덧셈. 캐리되는 값은 버린다.
Maj : 비트의 다수결에의해 결정되는 값
Ch : continual selection. 선택적으로 비트를 가져오는 연산

비트를 이리저리 옮기고 덧셈하고 선택하고

블록사이퍼의 라운드구조와 비슷하다

23)
2017년에 구글이 collision을 찾으면서 SHA-1을 깸

SHA-1, SHA-2와 다른 SHA-3의 표준화가 시작되었다

24)
SHA-2는 잠재적인 위험이 있다고 판단하여, SHA-3를 만들었다.

Keccak이라는 알고리즘을 사용

25)
SHA-3에서 쓰이는 파라미터들.
해시의 결과물(message digest)의 사이즈가 여러 개있다.

collision resistance는 해시값의 딱 절반임을 볼수있다

26)
SHA-3의 대략적인 구조

여러 라운드로 구성되어있다.

27)
5개의 스텝들. 그냥 이런게 있다.

차이점은
블록사이퍼와 랜덤하게 이리저리 섞어주는 것은 비슷하지만,
블록사이퍼는 키를 가지고 디크립션이 되지만
해시함수는 one-way 성질때문에 역으로 가는건 매우 어렵다는 것.

28)
정리

