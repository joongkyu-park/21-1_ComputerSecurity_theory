# 보안 11주차 이론

10장. RSA외의 다른 공개키 암호 시스템들

2)
목차

3)
공개키 암호가 응용되는 3가지 방식

- 데이터 암호화/복호화
- 전자서명
- 대칭암호에서 대용량 데이터를 암호화할 때 쓰는 세션 키 전달하는 용도 -> 하이브리드 방식. RSA를 이용한 key encapsulation 방식

RSA의 경우 3가지 방법이 어떻게 적용되는지 지난 시간에 했다.

4)
디스크리트 로그 복습

소수(19)로 모듈러스 연산을 했을 때 정수의 거듭제곱의 따른 모듈러스 값

19-1 = 18 제곱의 모듈러스는 페르마 소정리에의 해 모두 1
2,3 .. 과 같은 1~18의 수를 모두 생성해내는 수를 generator라고 함

디스크리트 로그 문제는, 2를 몇번 제곱하면 모듈러스 19 했을 때 15가 나올까(답은 11). 이게 어려운 문제 였음

5)
위의 사실을 이용해 Diffie-Hellman key 프로토콜을 만들었다.

공개키 알고리즘 중 가장 처음 제안된 알고리즘.
키를 교환하기 위한 알고리즘(RSA처럼 인크립션 위한 것 아님)

여러 통신 프로토콜에서 사용중. (ex: TLS)

Diffie-Hellman 프로토콜 목적
대칭암호를 위한 키 생성을 양쪽간의 똑같은 기여를 통해 안전하게 생성하는 것
RSA처럼 전자서명이나 인크립션과 같이 범용적으로 사용 x. 키 exchange만.

디스크리트 로그에 기반

Diffie-Hellman 문제라는게 따로 있는데, 그건 쫌 있다가

6)
Diffie-Hellman 예시

디스크리트 로그에서처럼, q = 19, ⍺ = 2 처럼 생각하면 된다

q와 알파는 누구나 다아는 글로벌 파라미터.

앨리스가 q보다 작은 범위내에서 랜덤한 숫자 생성 -> Xa
밥도 생성 -> Xb

앨리스는 다음과 같은 연산에 의해 Ya 계산
![보안 11주차 이론](images/보안%2011주차%20이론.png)

-> 이 계산은 어떻게했지? RSA에서 했었던 modular exponentiation 하면됨

밥도 같은 방법으로 Yb 생성

Xa는 앨리스만 알고있는 private key
Xb는 밥만 알고있는 private key
Ya는 앨리스의 public key
Yb는 밥의 public key

앨리스와 밥은 공개키를 서로 공유

그 이후 앨리스는 밥의 공개키와 자신의 개인키를 가지고 다음과 같이 K를 계산
![보안 11주차 이론-1](images/보안%2011주차%20이론-1.png)

밥도 마찬가지
![보안 11주차 이론-2](images/보안%2011주차%20이론-2.png)

=> 이 때 놀랍게도 두 값이 같은 값이 된다.

왜 이렇게 될까?

앨리스의 계산은 사실
![보안 11주차 이론-3](images/보안%2011주차%20이론-3.png)

이 과정

밥의 계산도 마찬가지로 이 과정이기 때문에 결국 같아진다.

이 K를 가지고 AES같은 블록사이퍼의 대용량 데이터 인크립션의 세션키로 사용하면 된다.

이게 왜 디스크리트 로그와 관련이 있는가

Xa와 Ya를 한번 보자.
![보안 11주차 이론-4](images/보안%2011주차%20이론-4.png)

알파를 주고, q를 주고, Ya를 알려줬을 때 공격자는 Xa를 계산할 수 있을 것이냐.

공격자는 
![보안 11주차 이론-5](images/보안%2011주차%20이론-5.png)

이 정보를 다 알 수 있다.

공격자가 Xa를 알아버리면 K를 알게되므로 곤란하다.
하지만 Xa를 알아내는게 디스크리트 로그를 푸는것과 같기 때문에 불가능 하다가 이 알고리즘의 생각.

-> diffie-hellman key exchange는 디스크리트 로그 문제가 어렵다는 가정에 기반하고있음.

그런데, 정확하게 이건 디스크리트 로그 문제가 아니라 Diffie-Hellman 문제가 된다.

공격자는 Xa를 알아내는게아니라 K를	 알고 싶은 것.

위의 정보로 부터
![보안 11주차 이론-6](images/보안%2011주차%20이론-6.png)

이 값을 구하는데 디스크리트 로그말고 다른 방법이 있다면, 그렇게 해서 또 공격할 수 있게 된다.

따라서 정확하게 Diffie-Hellman 문제란.
위의 4가지 정보를 가지고, 앨리스와 밥이 위와 같이 키를 생성해냈을 때, K를 알아내는 방법이 된다.

디스크리트 로그 문제가 풀리면 -> Diffie-Hellman 문제도 풀림
Diffie-Hellman 문제가 풀리면 -> 디스크리트 로그 문제가 풀리는 것은 아님.
즉 디스크리트 로그가 Diffie-Hellman 문제를 푸는데 유일한 방법이 아님

또 안전성이 보장되려면
Xa와 Xb를 공격자가 알아낼 수 없어야하는데,
만약 앨리스가 Xa를 잘못생성해내면 공격가능해짐.
앨리스가 랜덤하게 Xa를 생성해내는데,

예를들어 srand함수는 난수를 시간을 seed값으로 계산하여 생성하는데,
이러한 경우에 공격자가 추측할 수 있는 범위가 제한적으로 된다.
따라서 공격자는 몇 개 안되는 후보 Xa들을 가지고 공격에 성공할 수 있다.

Diffie-Hellman 프로토콜 자체는 문제가 없는데, 이러한 원인으로 실제 공격당한 사례가 있다.
따라서 난수발생의 시드에 유의해야한다.

7)
키를 교환하는 방법을 2가지 얘기했다
RSA, DH

둘의 차이가 뭐냐. Forward Secrecy

RSA같은 경우는,
밥이 공개키(e)와 개인키(d) 생성
앨리스가 밥의 공개키로 K를 인크립션해서 보내면, 밥은 자신의 개인키로 K를 디크립션.
그 K가지고 AES 이용하면 되는데,

이런 방식으로 1번째 세션에 K1 공유, 2번째 세션에 K2 공유 …
하다가 밥의 시스템이 해킹 당하여서 개인키(d)와 이전 세션들의 K를 암호화한 정보가 넘어감
=> 이전의 모든 세션에 대해서 다 정보가 뚫린다. 왜냐하면 d를 이용하면 모든 K1, K2… 들을 디크립션 할 수 있으므로

DF는 첫번째세션에 Xa, Xb를 개인키로 가지고 각각 Ya, Yb를 이용하여 K1를 인크립션
그러다가 n번째 세션에 해킹당하였다고 가정하면, 1~n-1번째 세션들의 정보는 해킹당하지 않는다.
왜냐하면 개인키 Xa, Xb는 해당 세션이 끝나면 필요가 없어지기 때문에 바로 버려진다.
따라서 이전 세션들의 정보를 가지고 있어도, 매 세션마다 사용되는 개인키가 다르기 때문에 forward securecy하다.

그러면 RSA에서도 매 세션마다 키를 generate해서 e,d 키 쌍을 만들어내면 되지 않나?
-> 가능하나,매우 비효율적이다.
 
따라서 forward secrecy를 위해서는 DF를 선택해야한다.

8)
또 다른 종류의 공격
Man in the Middle (MitM) Attack. 중간자 어택.
중간에 공격자가 끼는것.
이 공격은 DF뿐만이라 여러 통신공격에 쓰이기 때문에 문맥에 따라 조금씩 다르다.

DF에서의 중간자 공격은,

다스라는 중간의 공격자는
앨리스한테 공개키를 받고, 자신이 공개키를 생성하여주고,
밥한테 공개키를 받고, 또다른 공개키를 생성하여 주는 상황.

사실상 앨리스-다스, 다스-밥 사이에는 정상적인 DF 프로토콜이 이루어지고 있지만,
문제는 앨리스는 상대방이 밥, 밥은 상대방이 앨리스로 생각하고 있다는 것이 문제.

앨리스가 암호화된 데이터를 보내면, 다스가 키를 이용해서 복호화하고
그 플레인텍스트를 다시 밥과 통신할 때 쓰던 키를 이용해 암호화해서 보내면
밥은 자신의 개인키를 이용해 해당 암호문을 복호화한다.

-> 밥과 앨리스는 자신들이 안전하게 통신한것처럼 느끼지만, 중간에 다스가 다 보고있다는 것이 문제

이런 일이 벌어진 이유는,
밥 입장에서 내가 받은 공개키가 앨리스한테 온건지 다른사람한테 온건지 확인할 길이 없다는 뜻.
-> Authentication, integrity 이슈.

RSA와 공개키암호에 대해 흔히 하는 착각중에서. 키 전달이 완벽하기 된다 -> 아니었다.

대칭키 암호에서 키가 confidential하게 전달되는 것과는 또다른 문제.

모든 공개키 암호들은 상대방에게 나의 공개키를 어떻게 내것이 맞다라는 걸 확인시켜줄 방법이 필요.
비밀로 전달할 필요는 없으나, 내가 맞다라는 사실과 중간에 조작이 안되었다는 사실을 확인시켜줘야함
-> 이것을 하는 방법은 공개키인증서로 할 수 있다고 얘기했었다. 뒤쪽 챕터에서 다시다름

우리가 기억해야할것.
공개키 암호에 대해서 아무런 추가 작업을 하지 않으면, 공개키가 변조되어 전달되면서 지금과같은 중간자 공격이 가능해진다. RSA도 마찬가지.

9)
디스크리드 로그에 기반한 또다른 암호화 방법.
엘가말 인크립션.

디피헬만처럼 마찬가지로
q라는 모듈러스와
primitive root인 ⍺를
모든 사람들이 global public elements로 가지고 있다.

공개키의 일부라고 봐도되고, 모든 사람이 가지고 있는 파라메터다 라고 봐도된다.

앨리스가 키 쌍을 생성할 것,
밥이 앨리스에게 뭔갈 인크립션해서 보낼것.
상황은 RSA와 같다. 키교환이 목적이 아니라 데이터를 암호화해서 보내는 상황.
당연히 키 인캡슐레이션 용도로 써도 되지만, rsa와 똑같이 forward securecy 문제가 생기겠지.

디피헬만과 같이 private키 XA생성.
디피헬만처럼 공개키를 다음과 같이 계산
![보안 11주차 이론-7](images/보안%2011주차%20이론-7.png)

디피헬만과 다른점은, 세션키 생셩용으로 임시로 사용하는 게아니라, 이렇게 생성한 개인키-공개키 쌍을 앨리스는 지속적으로 사용할 것.

따라서 다음과 같이 정리
![보안 11주차 이론-8](images/보안%2011주차%20이론-8.png)

당연히 YA로 부터 XA를 쉽게 계산할 수 있으면 안되겠다.
이게 디스크리트 로그 문제의 가정이다.

밥은 데이터를 인크립션하여 데이터를 보낼 것네,
Plaintext M (q 모듈러스보다 작은 숫자라고 생각.)
여기선 싸이퍼텍스트가 2개 존재.

싸이퍼텍스트 1.
랜덤한 k(<q)생성. 앨리스가 키 제네레이션 할 때 했던 것처럼 임의의 랜던한 숫자를 뽑고, 
![보안 11주차 이론-9](images/보안%2011주차%20이론-9.png)

와 같이 계산.

싸이퍼텍스트 2.
앨리스의 공개키에 대해, 방금 뽑았던 k 제곱해서 K값을 만들고, (디페헬만과 비슷하다.)
![보안 11주차 이론-10](images/보안%2011주차%20이론-10.png)

다음과 같이 계산해서 싸이퍼텍스트2 만듬.
![보안 11주차 이론-11](images/보안%2011주차%20이론-11.png)

=> (C1, C2)

앨리스는 자신의 개인키를 가지고
(C1,C2) 싸이퍼텍스트를 복원해서 원래 플레인텍스트 M을 도출하면된다.

디피헬만 키 K를 계산하는 과정을 똑같이 한다.
K는 YA에 k제곱을 한 것인데, YA은 ⍺의 k제곱이었고,
C1의 XA제곱에서 C1은 ⍺의 k제곱이다.

즉 디피헬만에서 똑같은 밑수 ⍺에다가 일종의 밥의 임시 개인키 k 제곱이 되어있는 상태라고 볼 수 있다. 즉 밥의 임시 공캐키라고 볼 수 있다.
C1이 싸이퍼텍스트라고 했지만, 사실은 밥이 디피헬만 비슷하게 돌린 임시공개키를 만들어준 것이다 라고 생각할 수 있다. 그것을 자신의 개인키 XA제곱을 하면 똑같은 키를 유도해낼 수가 있는것.
![보안 11주차 이론-12](images/보안%2011주차%20이론-12.png)

따라서 위의 과정은 디피헬만키 K를 유도하는 과정이고,

K를 알았으면 C2로부터 M을 복원화는 과정에서, K의 역원을 곱해주면 M이 복원되서 나온다.

엘가마 인크립션은 디피헬만 key exchange하고 OTP(One Time Pad) 비슷한 것을 조합한 것이라고 생각할 수 있다.
One Time Pad? -> 클래식 암호해서 궁극적으로 완벽하게 안전한 암호를 언급한 적이 있었다. 내가 보내려는 플레인텍스트와 완전히 같은 길이의 랜덤비트스트림 키를 생성해낸 후, 그거와 플레인텍스트를 xor시키고 그 키를 한번 쓰고 버리면 아무리 슈퍼컴퓨터가 있어도 동전던지기이기 때문에 완전한 암호이다, 라고 했었다.
이런 방법이 현실적으로 불가능 하기 때문에 스트림 싸이퍼가 발생했었다.
조그만 키를 안전하게 공유할 수 있다면, 그 키를 seed값으로 해서 키 제네레이션을 하고 플레인텍스트만큼의 길이를 만들면 -> 공격자입장에서는 one time pad와 구분할 수 없게 된다.
블록싸이퍼가지고 그것을 emulation 해주는 방법이 아웃풋피드백 모드라던지, 카운터모드라던지.. 스트림 모드들이 있었다!

이것을 다시한번 떠올려보자
내가 키를 안전하게 만들어낼 수 있고, 메시지를 xor할 수 있으면 안전한 방법이 보장된다.
메세지와 같은 길의 키를 상대방에게 어떻게 전달할 것이냐가 문제!
이것을 디피헬만 가지고 하겠다는 거다.
보내는 쪽에서는 상대방의 공개키를 통해
![보안 11주차 이론-13](images/보안%2011주차%20이론-13.png)

라는 키를 만든것이고

받는 쪽에서는 상대방의 임시공개키인 C1을 자신의 개인키 XA를 이용해서
![보안 11주차 이론-14](images/보안%2011주차%20이론-14.png)

다음과 같이 계산한다는 뜻이다.

이렇게 해서 만들어진 디피헬만키 K를 가지고 원타임패드에서 쓰는 키처럼 활용하면 된다는 것.
약간 차이가 있는 것은 xor대신에 곱하기를 썼다.
![보안 11주차 이론-15](images/보안%2011주차%20이론-15.png)

이 부분에서.

xor는 디크립션할때도 xor지만,
곱하기는 복호화할 때 나누기 해주는것 정도의 차이
![보안 11주차 이론-16](images/보안%2011주차%20이론-16.png)

그러나 개념상으로보면, 엘가말 인크립션은 디피헬만Key exchange에 원타임패드 비슷한 개념을 접목한 것이다, 라고 생각하면 되겠다.

10)
세번째 암호.
Elliptic curve arithmetic.

대부분의 공개키 암호를 쓰는 제품은 RSA를 쓰고 있다. 인크립션용으로도 쓰고, 전자서명으로도 쓰고.
키의 길이가 안전성 요구조건이 올라가면 키의 길이도 길어진다.
AES-128 정도의 안전성을 가지려면, 지금 알려져있는 소인수분해 푸는 알고리즘으로 생각해봤을때 RSA는 3072비트정도의 모듈러스를 써야한다.
키 길이가 길다고해서 공개키 암호가 더 안전하다는 뜻이 아니다,라는 얘기를 했었다.
말하자면 2048-bit RSA는 128비트 AES보다 더 약하다는 뜻.

그런데 이렇게 긴 길이의 숫자를 다루게 되면 계산도 많이해야하고 메모리도 많이 잡아먹고 …

-> 최근에 이러한 문제에 대한 대안으로 타원곡선암호(Elliptic curve cryptograhpy)가 여러군데서 표준화가 되고 있다.
![보안 11주차 이론-17](images/보안%2011주차%20이론-17.png)

같은 안전성을 주기위해서 더 짧은 키를 써도 된다.
-> 같은 키 길이일 때 타원곡선이 더 안전하다.

자동차 통신같은 경우, 차가 빠르게 달리는 와중에 통신을 해야하는데 패킷 길이가 길면 통신하는 와중에 지나쳐버릴 수 있기 때문에 패킷크기가 작은게 굉장히 중요하게 여겨진다.

3072비트 RSA의 안전성과 비슷한 타원곡선암호는 256비트 정도의 키를 사용한다

11)
타원곡선암호과 기존의 공개키암호가 어떻게 비교되는지.

아래는 NIST에서 표준화한 키관리의 권고사항에 대한 표준.
security strength가 80이라는 뜻은 공격자가 2^80의 연산을 해야한다는 뜻.
만약 security strength가 128-> 256이 된다는 것은 2배 안전해지는게 아니라 2^128배 안전해진다는 뜻

AES의 경우 무작위로 대입하는게 아직까진 가장 효율적인 공격이라고 알려져있음.
현재까진 128 정도의 안전성을 요구함. 시간이 지나면 점점 커지겠지.

FFC(Finited Field 상의 Discrete logarithm에 기반한 암호들)
 
디스크리트 로그 기반 암호화나, RSA는 공격자가 깰 때 비슷한 알고리즘을 사용하게 된다.
이는 가능한 경우의수를 무작위로 대입하는 거보다 팩토링(소인수분해)알고리즘 (number field sieve와 같은)이 더 효율적이므로, 1024일 때 2^80 연산정도가 필요하게 된다.
RSA에서 k=1024라는 건 모듈러스 n이 약 2^1024라는 뜻이고, 개인키 d도 약 2^1024라는 뜻
디스크리트 로그에서 L=1024라는 뜻은 모듈러스의 크기와 지수의 크기가 대략 비슷하게 되는데, 그 수가 1024라는 뜻

![보안 11주차 이론-18](images/보안%2011주차%20이론-18.png)

요약하면 RSA이나 디스크리트 로그계열 암호들은,
모듈러스에 비해 훨씬 적은 안전성을 제공하게 된다. number field sieve같은 팩토링 알고리즘 때문에..

타원곡선쪽은, 요구되는 안전성에 대략 2배정도 되는 키를 쓰면 안전하다는 것이 알려져 있다.

따라서 타원곡선과 RSA를 비교해보면 같은 비트의 안전성을 제공하기 위해 훨씬 적은 키를 요구하고, 증가율도 더 낮다.
타원곡선은 안전성이 2배증가 -> 키가 2배증가 하면되는데
RSA는 안전성이 2배증가하려면 -> 키는 훨씬더 증가해야한다. 이유는 팩토링 알고리즘이 복잡도가 선형으로 증가하지 않게 때문에.

이렇다 보니 최근에는 점점 타원곡선 암호를 많이 사용하고 있다.
![보안 11주차 이론-19](images/보안%2011주차%20이론-19.png)

12)
본격적으로 타원곡선 암호에 대해 이야기전에 복기해야할 개념들.

아벨리안 그룹.

…

13)
싸이클릭 그룹

제너레이터가 있고 제너레이터의 거듭제곱에 의해 모든 원소를 만들어낼 수 있는 상황
…

14)
본격적으로 타원곡선 연산
타원곡선 : y에 대해 2차식인데 x에 대해 3차식임

두 점 P, Q에 대한 덧셈을 정의한다.
![보안 11주차 이론-20](images/보안%2011주차%20이론-20.png)

이게 아니라.

P, Q를 지나는 직선을 그린 후 제 3의 점에서 만나면, 그 점을 그래프의 x축에 대해서 대칭시킨 지점을 P+Q 라고 정의
![보안 11주차 이론-21](images/보안%2011주차%20이론-21.png)

P+P = 2P를 정의하고 싶으면, P에 접선을 그려서 똑같이 진행

이렇게 정의하면 싸이클릭 그룹을 만들어낼 수 있다.
![보안 11주차 이론-22](images/보안%2011주차%20이론-22.png)

P를 통해서 덧셈을 구해나가다 보면, 언젠간 자기 자신으로 돌아오는 싸이클릭 그룹이 된다.
(물론 실제론 P를 하나씩 더하지 않고, 덧셈과 곱셈을 적절히 이용.)

싸이클릭 그룹이 되었기 때문에 디스크리트 로그같은 비슷한 문제를 정의할 수 있다.
kP = Q인 Q를 구할 수는 있지만,
P와 Q를 주고 k를 알아내는 것은 쉽지 않다.
이것을 타원곡선상의 디스크리트 로그 문제라고 부른다.

디스크리트 로그와 비교.
![보안 11주차 이론-23](images/보안%2011주차%20이론-23.png)

15)
위에서 한 얘기 정리.

타원곡선상의 덧셈이, 마치 finite field 상의 모듈러 곱셈과 같은 연산이 되고,

여러번 더하는(multiple addtion)이 modular exponentiation과 비슷한 역할을 하게 된다.

kP = Q의 관계에서, (P, Q는 그래프 위의 두점)
k, P가 주어졌을 때 Q를 구하는 것은 쉽다.
그러다 Q, P가 주어졌을 때 k를 구하는 문제는 어렵다.
-> 이 문제를 elliptic curve discrete logarithm(ECDLP)라고 부른다.

![보안 11주차 이론-24](images/보안%2011주차%20이론-24.png)

->같은 x(개인키 역할)크기라면 일반적인 디스크리트 로그 문제보다 더 어렵다는 것.
따라서 더 작은키를 사용할 수 있게 된다.

16)
위 사실을 이용하여 디스크리트 로그 문제에 기반하는 여러 알고리즘, 프로토콜들을 그대로 옮겨서 쓸 수 있다.

디피헬만을 예로 들어 바꾸어보자.

마찬가지 generator 점과 모듈러스 q가 있었던 거섳럼
모듈러스 q에 해당하는 타원곡선 식이 있어야한다 -> Eq(a, b)	
또 어디서 부터 시작할거냐 시작점이 있어야함 -> G (generator point 또는 primitive point)

앨리스와 밥이 키교환을 하려고한다.

1G, 2G, 3G … 의 order에서 n번만에 G로 돌아온다고 가정하면,

앨리스는
n보다 작은 범위에서 랜덤한 nA를 뽑고,
![보안 11주차 이론-25](images/보안%2011주차%20이론-25.png)

다음과 같은 공개키를 만든다.
(원래 디피헬만에서 ⍺nA인것처럼)

밥도 마찬가지로

![보안 11주차 이론-26](images/보안%2011주차%20이론-26.png)

앨리스는 PB를 받고 밥은 PA를 받는데,
앨리스는 PB에 자신의 개인키를 곱하면 키 K를 계산할 수 있다.
![보안 11주차 이론-27](images/보안%2011주차%20이론-27.png)

밥도 같은 과정으로 K를 얻을 수 있다.

공격자 입장에서 알고 있는 정보
![보안 11주차 이론-28](images/보안%2011주차%20이론-28.png)

여기서 공격자가
![보안 11주차 이론-29](images/보안%2011주차%20이론-29.png)

를 알아내는 문제가 ECDLP 문제.
이 문제를 못풀기 때문에, 다음과같은 공개키를 알아도 K를 제 3자가 알아내는 것은 어렵구나, 를 이용한게
Elliptic curve를 이용한 Diffie-Hellman Key exchange가 된다.

그런다 여기서 nA, nB가 디피헬만에서 사용하는 xA, xB 보다 훨씬 작아서 훨씬 효율적이라는 뜻

17)
교재에 타원곡선을 엘가말에도 적용하는 예가 있지만, 자명해서 설명x

다시 한번 정리
- 타원곡선암호은 ECDLP에   기반
- ECDLP를 깨는 가장 좋은 방법은 Pollard rho method DLP에도 같은 방법 적용할 수 있지만, DLP에은 더 빠르게 깰 수 있는 알고리즘이 존재한다
- 더 짧은 키를 이용해 비슷한 안전성 제공가능하므로 더 효율적

18)
내용 정리
 
보통 공개키 암호는 암호화용도, 전자서명용도, 키교환 용도 3가지 용도로 사용하는데,

그중에 키 교환 용도 전용으로 사용하는 Diffie-Hellman Key Exchange 프로토콜이 있었고, 거기에 적용되는 공격들이 있었다.

디스크리트 로그기반의 encryption용으로 사용하는 Elgamal cryptographic system에 대해서 얘기했다

디스크리트 로그를 타원곡선 상의 문제로 옮겨놓은, ECDLP에 기반한 Elliptic curve cryptography.
DLP와 비슷한 구조이나, 같은 안전성을 주기 위해 더 짧은 키를 사용해도 되기때문에 더 효율적이다.
+)디피헬만을 타원곡선으로 바꾸는 ECDH

