# 보안 5주차 보강(5단원)

5장. Finite fields

2)
2장에서 배웠던 수학적 기초를 다지는 것의 연장선.

3)
2장의 내용 어떤 개념이 나왔었나 복습

4)
Groups
그룹은 2가지에 대한 순서쌍.
어떤 연산과 집합을 합쳐서 정의.
어떤 집합이 있는데, 그 집합에 대해서 어떤 연산을 연계시킴
그 연산을 이 집합에서 상에서 했을때 어떤 성질이 만족하느냐에 따라 '그룹'이라고한다,

그룹의 되려면 아래 4가지 성질을 만족해야한다.

1. 닫혀있음
그룹 내의 임의의 두 원소를 뽑아 연산을 시키면,
그 연산값이 집합안에 있어야한다.

2. 결합법칙
결합법칙에 닫혀있어야한다.

3. 항등원
임의의 원소 a에 대해 다음과 같이 항등원과 연산했을때 a가 나와야 한다.

4. 역원
항등원과 마찬가지. 역원과 a를 연산했을때 e(항등원)이어야함.

그럼 어떤 연산이냐? 더하기? 곱하기?
해당 연산이 덧셈이면 additive group
곱셈이면 mulplicative group 이라고 할 것.

5. 교환법칙
까지 성립할경우 가환군(abelian group)이라고 부른다.

5)
Cyclic group

- exponentiation(멱승, 지수승)은 그 그룹의 연산을 반복해서 적용하는 것을 의미
교재의 표현이 곱셈같지만, 곱셈을 의미하는건 아님. 걍 일반표현

- 편의상 a의 0제곱을 항등원이라고 표현.
곱셈같이 표현되었네.
진짜 곱셈이면 항등원이 1이겠고, 덧셈이면 0이겠다.

역원에 대한 연산은
![보안 5주차 보강(5단원)](images/보안%205주차%20보강(5단원).png)

이렇게 정의 하겠다.

- 어떤 그룹이 cyclic이라는 것은,
특정원소 a가 그룹안에 있을 때
a의 몇제곱 형태 (a에 같은 연산을 반복한 형태) 로 그룹 내의 모든 엘리먼트를 표현할 수 있다면
그 그룹을 싸이클릭 그룹이라고 한다.

-> 2장 내용의 discrete log에서,
[ ] mod 19 를 했을 때, 2와 같은 숫자는
2^1, 2^2, … , 2^18 처럼 곱셈연한을 exponentiation항에따라
안에있는 모든 원소 (1~18)를 다 만들 수 있다.
-> 싸이클릭그룹
이 때 a=2가 되는 거고, a를 generator라고 한다.

- 싸이클릭 그룹은 당연히 abelian그룹일 수 밖에 없다.

덧셈연산에 대해서도 생각해보자
mod 19에 대해 덧셈연산을 한다고하고
1을 1번더하냐 2번더하냐 … -> 모든 원소가 만들어지고
모든 원소는 k*1 형태로 표현될 것.

6)
필드

필드라는 것은, 어떤 집합과 연산 2가지를 가지고 정의. (그룹은 연산 1가지였음)
보통 이 연산이 덧셈과 곱셈이 된다.

어떻게 되면 필드가 되느냐.
앞서 본 5가지 특성을 만족하면 아벨리안 그룹이라고 했는데,
- 덧셈과 곱셈에 대해 모두 아벨리안 그룹이되고,
- zero divsior가 없다 (ab=0이면 둘 중하나가 0이어야한다)
- 덧셈과 곱셈에 대해 분배법칙이 성질할때  => 이것을 모두 만족하면 필드라고 표현

그냥쉽게 덧셈과 곱셈에 대해 둘다 그룹이면서, 분배법칙이 된다. 정도

근데 덧셈에 대해 그룹이 된다라는것은,
a+b가아니라 a-b를 생각해보면,
b를 뺀다는건 b에 대한 덧셈의 역원을 더하는 것과 같다. -> a + (-b)
그룹이 되려면 역원이 존재해야한다.
그러니까 덧셈 연산을 잘정의하고 그룹을 만들 수 있으면
역원을 정의할 수 있고 그걸 더하는 연산으로 인해
뺄셈을 정의 할 수 있다

마찬가지로
a / b = a x b^-1로 표현할 수 있다. (곱셈에 대한 역원을 곱함)
곱셈연산에 대해 그룹이 잘 정의가 되면
곱셈에 대해 역원을 구할 수 있고 그것을 곱할 수 있으니까
나눗셈이 자연스럽게 정의가 된다.

즉 덧셈에 대해 그룹이다 -> 덧셈과 뺄셈이 잘 정의된다.
곱셈에 대해 그룹이다 -> 곱셈과 나눗셈이 잘 정의된다.

지금은 덧셈곱셈에 대해 다 그룹이 여야하므로 4가지연산이 잘되어야한다.
쉽게 말하면 필드는 덧셈,뺄셈,곱셈,나눗셈이 그 집합을 떠나지않고 사칙연산이 잘 정의되는 구조
라고 생각해도 된다.

그래서 유리수라던가 실수라던가 복소수라던가 이런 집합들은 필드의 예다.
그러나 정수집합은 필드가 아니다.
multiplcativve inverse가 없다.
ex) 3의 곱셈에 대한 역원 1/3은	정수집합에 없다.
정수집합은 덧셈에 대해서 그룹이지만 곱셈에 대해선 그룹이아니고 그래서 필드가 될 수 없다.

7)
필드 중엔, 
복소수, 실수 처럼 무한히 원소가 많은 집합도 있지만
원소의 개수가 유한한 집합이 있다. -> Finite fields
파이나이트 필드를 갈루아의 이름을 따서 GF(Galois Field)라고 부른다.

원소의 개수가 유한하다고 했는데,
그 원소의 개수가 반드시 소수의 정수제곱개 만큼 밖에 안된다는 사실이 알려져있다.
즉 finite field(유한체)가 되려면
유한한 원소의 개수라는게
![보안 5주차 보강(5단원)-1](images/보안%205주차%20보강(5단원)-1.png)

형태로만 된다.

ex) GF(15)는 존재하나? 아니다. 3x5이므로.
GF(7)은? 7= 7^1 이기때문에 해당된다.
그러나 이런 집합은 특별한 필드를 GF(p), 프라임 필드라고 부른다. 원소의 개수가 프라임 개다.

8)
지금 우리가 얘기할건
GF(p)에 대해서 얘기할 것.

- finite field자체가 암호에서 굉장히 중요한 역할을 한다.
- 그 중에서도 n=1인 형태, 즉 프라임필드가 중요한 역할을 한다

9)
2장에서 봤던 모듈러 8에 대한 덧셈 테이블

10)
모둘려 8로 했을때 곱셈 테이블

11)
덧셈에 대해서는 역원이 항상존재하는데
곱셈에 대해서는 역원이 항상 존재하지는 않고,
언제 역원이 존재하냐면
역원을 구하려는 원소가 modulus와 서로소면 곱셈에 대해 역원이 존재하게 된다.

그러면 모둘러스가 n일때  1~n-1까지의 모든 원소중에서(0은 제외) 다 역원이 존재하게 할라면,
즉 서로소이려면 n이 소수여야한다.

12)
모듈러 7에 대해

덧셈테이블

13)
곱셈에 대해서도 모듈러 7
0은 제외하면
1~6까지의 숫자보면 역원 다 존재

예를들어 3의 곱셈에 대한 역원을 구해라,하면 어떻게 했었나?
![보안 5주차 보강(5단원)-2](images/보안%205주차%20보강(5단원)-2.png)

지금 같은경우는 숫자가 너무 작아서 그냥 구할 수 있지만..
->  확장유클리드 알고리즘을 쓰면 된다

결국 하려는 얘기가 뭐냐면
모듈러스 7에 의해서
0~6까지의 원소들이 필드가 잘 구성이 된다. 를 이야기 하려는 것.
즉 0~6까지의 원소에 대해
덧셈 mod 7에 대해 닫혀있고,
결합법칙 성립하고
항등원, 역원 존재하고
곱셈 mod 7에 대해서도 닫혀있고
결합, 항등원, 역원 다 있고
-> 덧셈, 곱셈에 대해 모두 그룹이고
교환법칙도 되니까 아벨리안 그룹도 되고
덧셈과 곱셈사이에 분배법칙도 성립하니까

=> 필드를 구성하기 위한 모든 조건 만족.
실제로 원소 7개짜리 (0~6)의 집합음
덧셈 또는 곱셈 mod 7에 대해 필드가 된다.
원소가 7개인데 유한한집합이 됐으니 finite field이고 프라임 필드이다. GF(7)

GF(7)라는 필드는 원소들과 연산 2가지로 정의된다고 했는데
{0,…,6}과 + mod 7, * mod 7을 모아서 필드가 정의된다.

14)

15)
그러면 지금은 프라임필드에 대해 얘기했고,

다음은 바이너리 필드

유한체, 즉 파이나트 필드가 되려면
GF(p^n)의 형태가 되어야하는데
특별한경우가 n=1인 필드를 프라임 필드라고 한다.

또다른 특별한경우는 p=2인 필드를 바이너리 필드라고 한다.
![보안 5주차 보강(5단원)-3](images/보안%205주차%20보강(5단원)-3.png)

AES에서 바이너리 필드를 쓰게된다
공개키암호(rsa같은)에서 프라임 필드를 쓰게 된다.

왜 이런 바이너리 필드를 쓰느냐
굳이 바이너리필드를 쓰는이유. 프라임 필드를 써도 될거같은데
DES같은 암호헤서 입력이 64비트짜리 플레인텍스트 블록이 들어왔다.
이걸 32비트씩 쪼개서 사용하고..
AES같은경우는 8비트씩 쪼개서 사용하고.. 이러는데
8비트의 경우 0000000~11111111의 가지수가 256가지.
이 256은 소수가 아니기 때문에 프라임필드로 다룰 수 없다.
하지만 GF(2^8)라는 파이나이트 필드는 확실히 존재하고, 이걸로 다루겠다는 뜻.
바이너리필드가, 우리가 익숙한 컴퓨터의 바이너리 구조와 잘 맞으니까.
근데 이걸 프라임필드같이 mod 7 이렇게 다룰 수 없어서 다른 방법이 필요하다

16)
그걸 하기 위해서 
polynomial 연산을 사용한다. (다항식 연산)

일반적인 익숙한 다항식 연산을 먼저하고
계수들이 모듈러스에 의해 모듈러리덕션 되는 다항식을 다루고
마지막은 다항식 자체를 다른 다항식으로 모듈러 리덕션 하는 거까지 한다

17)
일반적인 다항식.

덧셈, 뺄셈, 곱셈, 나눗셈

18)
마지막 다항식의 나눗셈에 대해서,
2장의 정수 나눗셈과 비슷한 규칙을 적용할 수 있다

![보안 5주차 보강(5단원)-4](images/보안%205주차%20보강(5단원)-4.png)

다음과 같이 표현할 수 있겠다.

만약에 r(x)가 0이면
g(x)는 f(x)를 나눈다고 표현하고
![보안 5주차 보강(5단원)-5](images/보안%205주차%20보강(5단원)-5.png)

기호로 저렇게 표현
g(x)를 인자, 약수라고도 표현할 수 있다.

다항식에서의 소수개념을 irreducible라고 한다.
어떤 다항식 f가 필드상에서 irreducible이라고 하는것은,
f(x)라는 다항식이 다른 차수가 더 작은 2개 이상의 다항식의 곱으로 표현할 수 없음
예)
![보안 5주차 보강(5단원)-6](images/보안%205주차%20보강(5단원)-6.png)

이런걸 irreducible polynomial이라고하고
소수같은 역할을 해서 prime polynomial이라고도 한다.

19)
2번째 단계.
계수를 GF(2)에서 다루는 연산.

![보안 5주차 보강(5단원)-7](images/보안%205주차%20보강(5단원)-7.png)

더한 결과의 계수를 mod 2 함

![보안 5주차 보강(5단원)-8](images/보안%205주차%20보강(5단원)-8.png)

뺄셈결과도 위와 같음

-> 덧셈 mod 2와 뺄셈 mod 2가 같은 연산. 
XOR과 같음.

따라서 GF(2)의 계수들을 사용하는 다항식 덧셈이나 뺄셈 연산은
차수 별로 같은 차수 끼리 계산하되, 계수끼리 xor시키는 것과 같다.
그러다니 보니 덧셈과 뺄셈이 같은 연산이 된다.

곱셈, 나눗셈도
계수에 mod 2 해야하므로 다음과 같은 결과가 나오겠다.
![보안 5주차 보강(5단원)-9](images/보안%205주차%20보강(5단원)-9.png)

20)
나누기가 가능하니까
다항식들 간의 gcd도 계산할 수 있겠다.
c(x)가 a(x), b(x)의 gcd가 되려면

- c가 a,b의 둘다의 약수이면서
- a,b의 모든 공약수들이 c의 약수일때, 즉 공약수들 중에 c가 가장 차수가 높을 때

즉, 공약수가 되는 다항식 중 차수가 제일 큰것

당연히 유클리드 알고리즘으로 gcd를 구할 수 있다.

21)
유클리드 알고리즘이 되니까
확장 유클리드 알고리즘 된다.
-> 확장 유클리드 알고리즘은 곱셈의 역원 구하는데 썼었다.

![보안 5주차 보강(5단원)-10](images/보안%205주차%20보강(5단원)-10.png)

이런 다항식을 모듈러스로 했을때,

![보안 5주차 보강(5단원)-11](images/보안%205주차%20보강(5단원)-11.png)

이 다항식의 곱셈의 역원을 구하는 과정을 보자.

스샷참고

최초에 1, 0
0, 1 계수로 시작하는건 똑같다.
두 식으로 r(-1) r(0)를 구했으면 그거 두개를 나눠서 q1(x)를 구하고,
바로 위식에 곱해서 빼준다.(-x를 곱하는거) 
이 과정을 반복.

mod 2 동네에서는 -x랑 x랑 같다.
그래서 테이블에 -x가 없다.

r = 1이 될 때 까지 반복

그래서 결국
![보안 5주차 보강(5단원)-12](images/보안%205주차%20보강(5단원)-12.png)

의 식이 되는것.

근데 우리가 원래 구하려는건
![보안 5주차 보강(5단원)-13](images/보안%205주차%20보강(5단원)-13.png)

의 역원. ( 이게 b(x) )

![보안 5주차 보강(5단원)-14](images/보안%205주차%20보강(5단원)-14.png)

왼쪽은 a(x)의 배수니까 그냥 1이 된것.

따라서 x^7이 b(x)이 b(x)의 곱셈이 역원이 된것.

근데 이게 될려면
![보안 5주차 보강(5단원)-15](images/보안%205주차%20보강(5단원)-15.png)

이 두 다항식이 서로소여야 가능하다.

그래서
![보안 5주차 보강(5단원)-16](images/보안%205주차%20보강(5단원)-16.png)

이와 같은 다항식이
자신보다 차수가 낮은 모든 바이너리 다항식들과
gcd를 구했을 때 1이 나오는 프라임다항식이어야한다.
그래야 모든 원소에 대해 역원이 있을 것.

위와 같은 다항식의 조건?
8차보다 낮은 차수의 인자들을 안갖는것.
1과 자기자신 이외에 팩터가 없는거고
다른 어떤 다항식이와도 gcd를 구하면 1이 되는거고, 역원이 존재하는것.

22)
방금 전에는 8차다항식을 모듈러스로해서 곱셈의 역원 구하는걸 해봤다.
그 다항식이 뒤에서 aes에서 사용하는 정확히 그 다항식.

그거로하면 계산 복잡하니까 3차다항식으로 바이너리 필드를 설명해보자.

여기서 다루는 필드는 GF(2^3)와같은 원소 8개짜리.
(AES에서 쓰는건 GF(2^8) )
 
GF(2^3) 이러한 원소 8개를 갖는 다항식을 정의하려면
![보안 5주차 보강(5단원)-17](images/보안%205주차%20보강(5단원)-17.png)

위와같은 3차의 irreducible polynomial이 필요하고,

256(2^8)개의 원소를 갖는 파이나이트 필드를 정의하려면 8차의 irreducible polynomial 필요한 것.

그러면 원소 8개를 어떻게 정의하냐.
2차식의 계수를 쓰는데 각각의 계수를 0또는 1로 해서 8개를 만들어 낸다.

이 8가지 원소들에 대해서
덧셈, 곱셈에 대해 모든 조합을 만들어 본것

계산은 그냥 비트로 xor시키고 그 숫자로 계수 붙이면 간단하다.
자기와 자기를 더하면 항상 0이 나온다.
모든 원소는 자기자신의 덧셈의 역원이다.

곱셈에 대해서는.
곱셈을 했을때 3차항 이상이 생겼다
-> 모듈러스로 모듈러리덕션 시켜서 그 때의 나머지가 결과값. (숫자일때와 같은 흐름)

2차이내의 바이너리다항식들 끼리의 곱셈이, 모듈러스 다항식(irreducible)을 이용해서 잘 정의가 됨을 알 수 있다.

따라서
덧셈이던 곱셈이던 닫혀있고 결합,항등원,역원,교환 다되어서 아벨리언 그룹이 되면서 필드가 된다.

역원은 어떻게 확인 하느냐. 곱셈에 대해서
![보안 5주차 보강(5단원)-18](images/보안%205주차%20보강(5단원)-18.png)

이 다항식들은 
![보안 5주차 보강(5단원)-19](images/보안%205주차%20보강(5단원)-19.png)

이 다항식과 서로소다.
왜냐하면 이 다항식은 인수분해가 안되기때문.

그래서 곱셈테이블에 어떤 원소가 됐던지 1이 되는 값이 1개씩 존재

23)
하나 헷갈리면 안되는 것.

위에서 다항식을 축약해서 비트로 그냥 표현했었음.
계수만 따가지고 편의상.
![보안 5주차 보강(5단원)-20](images/보안%205주차%20보강(5단원)-20.png)

곱셈을 가지고 설명하자

24)
100 과 100을 곱셈해서 6이 된다는게
4와 4를 곱해서 8과 모듈러해서 6이 되는게 아니다. 당연.

x^2과 x^2를 곱해서 모듈러 리덕션하면
6, 즉 110 이니까 x^2 + x가 나오는구나, 이렇게 해석을 하자는것

25)
그래서
이 원소 8개짜리 바이너리필드 상에서의 역원들을 생각해보면
3의 역원이 6이다 -> x+1 과 x^2+x 를 곱하면 순간적으로 3차 다항식디 되었다가,
			 모듈러리덕션을 해주면 1이 된다는 뜻

즉 앞에서 mod 8 했을 때 곱셈에 대해서 역원이 없는 경우와 혼동하면 안된 다는것.

2의 거듭제곱에 대해 파이나이트 필드를 구성하려고하면
8이라고 해서 숫자 mod 8 로하는게 아니라는 것.

이렇게 하면,
처음에 프라임필드에서는 바이너리데이터들을 우리가 익숙한 형태로 다루기 어려웠는데,
이런식으로 바이너리 필드를 사용하면 잘 다룰 수 있겠다.

26)
또 한가지.
바이너리필드가 개념적으로 복잡해보이지만,
실제로 계산하는걸보면 계수가 0,1 뿐이기 때문에
자연스럽게 비트스트링이 되고
덧셈, 곱셈 연산들이 간단한 바이너리연산들로 쉽게 구현이 된다.

덧셈은 그냥 xor연산하면 되고
곱셈은 두 다항식 곱한다음에, 모듈러리덕션 한다음에.. 복잡해보였는데
사실은 그냥 쉬프트와 xor만으로 쉽게 구현된다.
왜그러냐,
모듈러리덕션이 사실은 나눗셈으로 구현되는게 아니라 차수가 넘어가는, 삐져나오는 항들을
더 차수가 낮은 항들로 대체하는 식으로 구현가능하기 때문.

27)
예를 보자.

여기서 이용하는 성질.
![보안 5주차 보강(5단원)-21](images/보안%205주차%20보강(5단원)-21.png)

이 사실을 이용해서 곱셈을 해보자.
모듈러 연산의 성질을 이용해서 쪼개서 계산하고 다시 합치는 방식

교재내용 참고

이건 그냥 개념적으로 설명하는 거고,
실제 계산은 다음과같이 한다

첫번째
![보안 5주차 보강(5단원)-22](images/보안%205주차%20보강(5단원)-22.png)

두번째
![보안 5주차 보강(5단원)-23](images/보안%205주차%20보강(5단원)-23.png)

쉬프트를 2번하는게아니라 방금 계산한걸 구해서 쉬프트 한번.

28)
책에 있는 더 복잡한 예제를 보자.

… 토할거같네
영상재참고

29)
요약..

