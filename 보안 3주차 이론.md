# 보안 3주차 이론

3주차 보안 이론

이제부터 지난수업에 간추린 키워드를 던질것. 복습차원.

1. 패시브어택 vs 액티브어택
2. 패시브어택을 막으려면 어떻게? (그것을 막기위한 시큐리티 메커니즘, 서비스)
 -> 암호화
3. 암호화해도 전송한다는 사실자체를 숨길 수없음, 통계적인에 대한 분석에 대한 공격 이름?
: 트래픽 어낼리시스
4. 그걸 숨길려면 전송한다는거 자체를 숨겨야함. 라우팅 자체를 숨김. ->막는법: 토르

전송한다는 사실자체 + 패시브어택 까지 이런거 다막아야 : 컨피덴셜리티

5. 액티브어택 방법 3가지
- 만들어서 보내기, 그사람의 신원가장하기 : 마스커레이드
- 중간에막기, 등등

6. 액티브어택을 맞기위해서 시큐리티서비스 6가지
그중에서도 가장 기본적인 3가지(삼각형)

그거 말고 2가지 더 추가해서 5각형

==> 그 코어컨셉 그림 제대로 이해하기 아니 외우기.. 앞으로도 계속 나올것

여기까지 챕터1

여기서부터 별도슬라이드로 했던부분

7. 엑세스 컨트롤중에, 엑세스컨트롤 정책 대표적 2가지 어떤거 있었냐
- DAC, MAC

8. DAC, MAC 차이
DAC : 임의적 접근제어, 맘든사람 맘대로, 자료만든 주인이 권한을 관리하겠다. 사용자가 관리자 권한 직접 지정
장) find-grained control이 된다
단) 이사람이 전체시스템을 망가트릴수도..

MAC : 시스템관리자가 전체적으로 주체와 객체들에 대해 권한, 수준을 부여해서 높은 사람은 높은 권한 주고.
시스템이 권한 지정

이런것을 구현하는 수단중에 엑세스 컨트롤 행렬(ACM)이 있었다.
아무권한도 없으면 비워놓을 것이고..
이렇게 했을 때 문제 -> 비효율적. 대부분의 시스템이 많은 사용자 주체, 객체들(심지어 수십만개)이 있음. 이것을
일일이 표로 표시한다는게 쉽지않다. 자원을 굉장히 많이 잡아먹을것. 또 대부분 빈공간인데 굳이 다 표현할필요가 있을가..

========================================================= 여기까지 저번주내용
11)
위 방법을 압축하는 방법
엑세스 컨트롤 리스트 (ACL) , DAC방법중 하나
유닉스,리눅스에서 사용하는 방법

방법...

공간을 절약할 수 있다.

12)
유닉스, 리눅스는 좀더 abbreviated된(줄여서) ACL사용.
DAC은 find-grained한다는 장점이 있었는데, 사실 이런 장점이 사라졌다고 볼 수 있다.
그룹도 세개밖에 안됨. 주인이냐 주인아니냐, 뭐 다른사람이냐(?). DAC의 장점이 사라짐.

윈도우즈도 비슷한 형태로 되어있다.

13)
압축하는 방식을 반대로, 주체(서브젝트)위주로 하는 방법 : CL (Capability List)

각 주체별로 객체에 대해 무엇을 할 수 있는지 권한을 명세하는 방법.
이것은 일종의 조작이 불가능한 티켓.
마치 놀이공원 이용자: 서브젝트, 놀이기구 : 오브젝트
표에 서브젝트가 무엇을 탈 수 있는지 써져있음.

오브젝트 위주면, 놀이기구별로 모든입장객(만명?!)에 대해 이 기구 탈수 있어없어 다써놓는것.. -> 이건 아니잖아 ㅠㅠ

14)
다른 비유.
안드로이드 앱에 주는 퍼미션을 생각해보자
앱들(주체)각각에 대해 스마트폰에 있는 어떤 리소스들을 접근할 수 있냐에 대한 명세.
이것이 대표적인 주체기반으로 명세하는 방식

15)
RBAC(Role-based Access Control) , 룰이아니라 롤기반.. 헷갈리지말것
역할기반.

16)
이게 앞에서 얘기했던 주체,객체기반이랑 다른게 뭐냐.

앨리스라는 사용자가 있을때, 그사람의 ID로 구분하는거보다
이 사람이 그 조직내에 어떤 직책을 가지고 어떤 역할을 가지느냐에 따라 결정하는게 더 합리적.

RBAC기반이 아닐때.
앨리스가 부서를 이동했다고 생각해보자.
특정 권한들은 뺏고, 특정권한들은 새로부여해야함.
-> 만약에 파일이랑 객체를 두고, 앨리스란사람의 id로 그걸 구분하게 되면, 
그 학생 데이터 파일 몇천개에 대해 엑세스권한을 없애자.. 또 마찬가지로 새로운 권한부여도 마찬가지

롤 기반이라면?
부서를 옮기면 그 부서에 맞는 권한들을 자동적으로 부여한다.
다른 장점들도 있음.
예)
은행에서,
대출계좌를 여는 권한.
태스크 별로 구체적인 역할을 줄 수 있다.
병원에서,
...
-> 세분화된 권한을 구분할 수 있다

이게 사실 DAC과 MAC을 합쳐놓은 듯함

17)
엑세스 컨트롤 하려면 그사람이 누군지 알아야돼 -> 사용자인증이 선행되어야함
User Authentication : 사용자 인증
사용자에 대해서, 이 사람이 진짜 그사람 맞냐
경우에 따라 indentification과 섞어서 쓰지만, 엄밀히 말하면 구분됨

indentification(식별) : 여러사람이 있는데, 내 눈앞에 있는 이 사람이 누구냐. 여러 후보중에 누구냐
Authentication(인증) : 시스템에 여러 아이디들이 있는데, 누가 나다! 라고 주장함. 주장하는 그사람이 맞다틀리다 하는것 인증.
-> 두개가 밀접히 관련은 있지만, 정밀히 같은 것은 아님

Authentication 하는 방법 크게 3가지 계열
- 그 사람이 알고있는 정보로
대표적으로 패스워드, 핀(PIN : Personal Identification Number : 개인식별번호) 등
여기서도 나누면 몇가지 계열이 있음(직접입력, 질문에대한 대답)
문제점들도 있다.

- 사용자가 가지고 있는 정보로
예를들어 정석들어갈때 학생증찍고 들어가는거..
위에처럼 10자리 패스워드 치고 그런과정없다! 편하다
문제점 -> 아무나 가지고 있으면 통과가 된다는것.. 잃어버리거나 도둑맞으면 다른사람에게도 액세스가 되버림.

- 그사람자체에 대한특성 또는 하는것에 대한 특성을 가지고 하는법 (생체인증, 바이오인증, 생체인식 등 이라고함) 
지문, 홍채, 얼굴, 정맥, 지문...
편하면서 안전하다는 장점..
단점 -> 홍채... 유출되었다 -> 복구안됨
서명 -> 유출.. -> 필체를 쉽게 바꿀수없다.

학생증-> 재발급받으면됨
패스워드 -> 재설정하면됨

=> 결국 상호보완해서 쓰거나 2개를 섞어서 쓴다.( two-factor Authentication )
흔한착각)
지문입력해 -> 잘안되 -> 너그걸로안되면 핀코드 입력해봐라 --> 두가지방법...사용했잖아..? => 이건 투팩터 Authentication이 아님 -> 이건 보안강도를 낮추는 방향으로 진행된것.
or조건임

투팩터 Authentication 는 and조건임. 2가지 다 해야된다!

쓰리팩터 Authentication 하면 더안전해지잖아?!! 하지만 불편해..
편의성과 안전성은 트레이드오프 관계

---끝----

2단원 정수론.
왠 정수론? -> 다음시간부터 암호에 대한 얘기할껀데, 정수론 얘기가 많이 나오기 때문. 중간중간 자주나올것. 그렇게 어려운 얘기아님.

2)
- 약수, 배수, 나누기 알고리즘
- 최대공배수, 유클리드 알고리즘
- 모둘려 아리스매틱
- 유클리드 알고리즘 확장, 역수..
- 소수
- 페르마 이론
- 오일러 함수
- 오일러 이론
- ....
등등등

3)
나눗셈이 가능한 성질, Divisibility
0이아닌 정수 b
a도 역시 정수
a를 b로 나눈다 == a=mb
기호로는 b | a (b가 a를 나눈다, b가 a의 약수다, a가 b의 배수다 .. 다 똑같음)
양수에 대해서.

음수도 a=mb 정의에 의하여 가능
30=m x (-5)  -> m = -6

4)
여러 특성들 ..

어떤 정수 b를 가지고와도 다 0의 약수가 된다.

5)
간단한 증명

6)
나누기 알고리즘
어떤 양의 정수 n
음수가 아닌 정수 a (하지만 음수도 마찬가지임)
a를 n으로 나눈다 -> 몫 q, 나머지 r를 구하는 과정
q와 r은 유일하게 정해지지않는데,
r에게 범위를 범위를 주면 몫과 나머지를 유일하게 만들 수 있다. (0<=r<n)

7)
a까지 가기위해서
n이 몇번필요하냐 -> q번
나머지 자투리 -> r

8)
나눗셈을 이용해서 약수, 배수 개념들을 정의했다.

두개의정수가 정수가 주어질때 공통으로 약수인것 , 공약수 (common divisior)
그중에 최대인것 최대공약수 (gcd, greatest c d)
그중에 가장 대표적인게 유클리드 호제법(유클리드 알고리즘)

두 정수의 gcd가 1일때 -> 그 두개의 숫자를 서로소(relatively prime)이라고 한다.

9)
GCD를 정의.. 여러가지방법이 있음..

여러 정의가있음.
 
양의 정수 c인데
a와 b의 약수 이기도하면서, 모든 공약수들은 c의 약수일 때 c는 최대공약수

맨 아랫줄은 공식으로 포멀하게 정의

10)
유클리드 알고리즘 순서도로 표현
입력으로 들어오는 숫자 a,b
a=b인경우에는 자명, 알고리즘 돌릴필요도없음. 자기자신. 신경쓸필요 x

이 알고리즘에서는 a>b 가정하고 증명. (반대로면 뒤집으면되니까)

a를 b로나누면 몫과 나머지가 생길것. but 몫에 관심없음.
나머지를 구해봤더니 0인지 아닌지를 구분해본다.
0이 아니면 a를 b에다 덮어쓰고 b에다 r을 덮어씀.
r=0인순간이오면 그순간의 b값이 GCD

11)
예
710과 310의 gcd를 구해보자

12)
또 다른예제

13)
모듈러 연산

나누기를 하는데, gcd를 구할때처럼 몫에는 신경안쓰고 나머지에 집중하는 연산

a 양의 정수, a를 n으로 나눔
-> a = qn+r , 0<=r<n; q= [a/n] -> floor연산
-> a= [a/n]*n + (a mod n)

그 때 그 n을 modulus라고 한다.

헷갈리는거
-11 mod 7
-11 = -1 x 7 - 4  ---> 안됌. r은 0보다 크거나 같아야해
-11 = -2 x 3 + 3 ---> O

14)
Congruent : 합동
두개의 정수 a,b
(a mod n) = (b mod n) 이면, 모듈러 n에 대해서 합동이다. ->   a ≡ b (mod n)

a ≡ 0(mod n) 주목.

예제 주목.

15)
Congruences의 성질

16)
모듈러 연산의 성질들.

17)
위 성질들이 무슨 의미가 있냐!
예시

윗방법 -> 나머지연산 3번
아랫방법 -> 나머지연산 1번
=> 어차피 결과 같으니까 연산 1번만하자
=> or 반대로 윗방법이 유용한 상황도 있다. 
   (10000x10000x10000x10000x1000x1000x .. ) mod 10023 이런 계산이 하고싶다
   쭉 다한담에 계산하면... 숫자가 너무 커짐.. c로 프로그램짜면 오버플로우남.
   나눗셈 자원이 좀 들긴하지만, 숫자의 크기를 줄이면서 유지할 수 있으니까~

따라서 두 방법을 왔다갔다 하면서 써먹을 수 있다. 어떤 상황이냐에 따라서.

18)
연산표.
모듈러 연산을 정의해봤으니까.
덧셈연산표.
각 셀들은 그 행과 열이 만나는 두숫자를 더한값인데, 모듈러 8 이 개입되어서 값을 정함.

0은 특별한성질이 있다. 더해도 소용없음 -> 항등원
역원도 존재 : 어떤 원소에 대해 짝궁을 더했을때 0이 되도록 만드는것.

각 행별로 0이 되는 셀이 하나씩 있다 -> 해당 그 원소에 대해 역원이 되는 짝궁이 존재한다.

19)
곱셈에대한 연산표

특별한원소2개
0, 뭘곱해도 0 -> 0하고 곱하는건 너무자명해서 고령나함
1 -> 항등원

원소에 대해 역원이 항상 있느냐, 아니다.

20)
w원소 0부터 7까지 있다. (모듈러 8 기준)
-w : 덧셈에대한역원
w^-1 : 곱셈에대한 역원

곱셈에 대한 역원이 있는 원소도 있지만, 없는 원소도 있다.
그럼 그런 원소들의 차이는 뭐냐?
-> 서로소냐 아니냐에 차이가 있다.
즉 8이라는 모듈러스와 서로소인 것들(1,3,5,7)은 역원이 있고
서로소가 아닌것들(gcd가 1이 아닌애들)은 역원이 없다.

21)
모듈러 연산의 성질
교환법칙, 결합법칙 .,,,등

22)
확장 유클리드 알고리즘
원래는 역원을 구하기위한 알고리즘은 아님. 여러가지 용도가 있음.
우리는 역원 구하는데 써먹을 것임

주어진 a,b (a>b)
ax + by = d = GCD(a,b)을 만족시키는 x,y,d를 찾아내는것.
그런 적당한 x,y를 찾는 과정을 확장 유클리드 알고리즘 이라고 한다
입력은 2개인데 출력은 3개

교수님이 지금 설명하는 방법과 책에 있는 설명 다르다. 하지만 교수님 설명이 더 직관적임.

ax1 + by1 = d1
ax2 + by2 = d2
를 만족하는 2개의 식을 유지할건데,
이런 식을 만드는게 쉽지않음
하지만 자명한 조합에서 부터 시작할 것.
x에 1, y에 0 -> d = 1759
x에 0, y에 1 -> d = 550

이 식에다 적당히 상수배를 빼고 더하면서 또하는 식들을 만든다.
무작정 만드는게 아니라 d 값이 점점 작아지게 만든다
스샷 참고

이걸 언제까지하냐.. 1까지

1759x(-111) + 500x355 = 1 일 때 어떤의미가 있느냐..
-> 550x355 = 1 + 1759x111
355가 우리가 원하던 역원 값..!

(550 * x mod 1759  = 1)

...

이제 우리는 숫자가 주어졌을때 곱셈의 역원을 구할 수 있다
==> 문제나올것 ..ㅎ

-------------------------------------------------------
23쪽부터 다음시간에~

