# 보안 6주차 이론
 
지난시간
플레인텍스트 : 일반문
사이퍼텍스트 : 암호화된 문
인크립션 : 암호화
디크립션 : 복화화
키 : 인크립션, 디크립션시 필요
보안유지는 키를 안전하게 유지하는것. 알고리즘을 숨기는 것이아니라. 알고리즘은 공격자도암

여러 싸이퍼 방식들.
싸이퍼 방식들의 진화.

30)
로우 트랜스포지션 사이퍼

여기서 키가 7.
7열을 가지는 행렬로 플레인텍스트를 씀.
마지막 남는 자리는 패딩으로 아무값이나.
그리고 열마다 순서를 랜덤하게 줘서, 숫자가 작은 열 부터 읽음

문제에서 1번이라고 써져있는 열 : ttna, 2번이라고 써져있는열 : aptm.. ->이런식으로 다 붙여서 사이퍼텍스트만듬

multiple rounds (라운드를 여러번 돌렸다)
![보안 6주차 이론](images/보안%206주차%20이론.png)

사이퍼텍스트를 바꾼걸 같은 방법으로 한번 더함.

꼬면 꼴수록 안전이 높아지는 거.. 단순함..
근데 암호화나 복호화 할때 좀 시간이 걸릴것..
안전과 속도는 트레이드오프관게

31)
로터 머신
몇십년전에 쓰인것.

자판을 하나 누르면 위에 다른 글자에 불이 들어옴

암호화 원리.
바퀴 둘레에 26가지 알파벳이 쭈욱 적혀있다.
쭈욱 펴서 직선형태로 만들어 보자

32)
바퀴 3개가 주어진거.

A라는 글자를 타이핑하면, 
세개의 바퀴의 전극들이 연결되서어
B자에 불이들어옴. A가 B로 바뀜.

바퀴 내부 전극의 연결관계는 고정되어있음. 무조건 숨겨야함. 이거 들키면 끝나는것.

한글자 타이핑할때마다 substitution이 바뀐다.
한 칸씩 밀림.
26번을 타이핑하면  첫번째 바퀴가 한바퀴가 돌고 두번째 바퀴가 한칸 돈다.
26x26x26

33)
*encryption의 두종류
- symmetric cipher 암호화 복호화 키가 같음 - block cipher - stream cipher
- asymmetric cipher(= public cipher) 암호화와 복호화할때 키가 다름

![보안 6주차 이론-1](images/보안%206주차%20이론-1.png)

스테가노그래피-> 이건 암호화가아님..!
인크립션과 다르게 메세지 내용이 변환되는게 아니라 그대로 살아있음.
어딘가 숨겨져서 여기저기 들어가있는 것 뿐.

각행의 마지막 단어를 모아보자.
![보안 6주차 이론-2](images/보안%206주차%20이론-2.png)

스테가노그래피 장단점.

단점 : 메세지 저만큼 밖에 안숨기는데 엄청나게 큰 오버헤드. 다른 메세지들도 숨겨야하니까

장점 : 메세지가 있다는 사실을 숨김 -> 트래픽 어낼리시스같은걸 시도 안하게됨

35)
스테가노 그래피 vs 인크립션

36)
요약

챕터 4.
block ciphers and the data encryption standard.

AES와 DES(data encryption standard.)가 있는데
des는 현재 쓰지않지만, 설계원칙이 현대에도 사용되고 중요함

2)
내용

DES의 자세한 구조를 알필요는 없다

5)
플레인텍스트를 암호화시키자.
100만비트가 있다고 치자.
안전하게 암호화하려면 100만비트짜리 키를 만들어서 xor시키면 완전하게 안전(one time pad같은것)
하지만 현실성이없음

그러나 128짜리 키를 가지고 bit stream genenration 알고리즘으로 100만비트짜리를 만듬.
-> 똑같은 입력주면, 똑같은 출력주는 디터마인한 알고리즘임. 랜더마이즈가 아닌.

공격자 입장에서 생성된 백만비트를 봤을때,
공격하잔테는 마치 랜덤처럼 보이게 만들어주는 것

이 100만짜리 비트와 xor

복호화할때도 키를 가지고 알고리즘 사용하여 xor
중간고사 이후에  나올것

블록사이퍼도 
128비트짜리 키를 가지고.
플레인 텍스트의 한블록(우리는 128로가정)
한블럭을 인크립션알고리즘 돌려서 싸이퍼텍스트 만듬

키를 고정한 상태로 나머지 블락도 똑같은 키로, 같은 방법으로 진행함.

복호화하는 쪽에선 인크립션 반대알고리즘 사용하면 되겠다.
물론 키는 같은거 써야함.

3)
스트림 사이퍼
시메트릭 인크립션임. (암호화 복호화 같은 키 사용)

4)
블록사이퍼
시메트릭 인크립션.

6)
블록 사이퍼에 대해서 본격적으로 얘기해보자.

7)
퍼뮤테이션 사이퍼에서는 26! 가지 수가 있었음. 각각 뭘로 대응시킬거냐.
한글자씩 대응시켜서 문제가 있었음

2글자 대 2글자로 매칭 시킬 수도 있다. -> 더 안전하겠다. (지난시간에 통계적인 차트에서)
그럼 3글자는? 4글자는?…
-> 이거의 극단적인 방식이 블록사이퍼

여기선 4비트 대 4비트로 대응시키는것.
16!가지

우리가 하고싶은건 통계를 아주 무디게 만들기위해 100글자 대 100글자 이렇게 하고싶은거
128비트 대 128비트

그런데 그만한 내용을 다 담을 테이블은 없음..#

8)
아까는 플레인텍스트 128비트를 싸이퍼텍스트 128비트 를 매칭시키는 테이블로 설명했는데,
그 인크립션 과정을 테이블로 설명하지않고
비트연산(함수같이)을 하는거,
가장 많이 쓰인게 feistel 방법

9)
이거 이해하려고 고전암호한거임.

64비트 블락 기준으로 설명해보자

32비트 32비트로 두개자름
왼쪽32비트는 오른쪽으로 이동 (트랜스포지션 시킨거)
오른쪽은 어떤 K에 의해서 함수를 거쳐 왼쪽으로 이동.

이게 1개의 라운드인데 16번 반복할꺼.
각각의 라운드에는 서브 K가 들어간다. (k1, k2 …, k16)
키는 64비트짜리를 받아서 어떠한 방식을 통해서 16개의 서브키를 만들어냄

입력으로 64비트 받고 출력으로 64비트냄

뭔가 복잡한거같은데
크게보면 대체하고 퍼뮤테이션하고.. 이런과정을 여러번 거친것.

오른쪽아래 도식은 전혀몰라도됨.

페이스텔 사이퍼는 복호화 어떻게 하냐
라운드를 순차적으로 내려왔으니까. 이걸 반대로 거슬러 올라가서 복원을 해야할거 잖아 상식적으로?
-> 근데 이게 아님.

역연산을 하는게 아니라 순연산을 다시함.
f의 역연산을 하는게아니라 순연산을 해서 xor을 시킨다.

근데 더 신기한건
이 과정을 그대로하면 디크립션이 된다.
맨 마지막 라운드에 주목해보자.
![보안 6주차 이론-3](images/보안%206주차%20이론-3.png)

단, 키순서만 16, 15,14 … ,1 으로 반대순서로 적용한다.
라운드 자체는 그대로.
![보안 6주차 이론-4](images/보안%206주차%20이론-4.png)

같은거랑 같은거를 xor하면 상쇄되니까.

=> RE16과 LE16에 K16을 넣고 한라운드 돌렸더니 RE15 LE15 나온것
…
이렇게 16라운드 돌리면
마지막에 RE0 LE0이 남음.
마지막에 스왑을 하면 LE0 RE0이 된다. = 플레인텍스트
![보안 6주차 이론-5](images/보안%206주차%20이론-5.png)

정리해서 다시써보겠습니다.
![보안 6주차 이론-6](images/보안%206주차%20이론-6.png)

왜 가능하냐?
페이스텔 사이퍼가 전체를 트랜스폼 시키지 않고, 반쪽에 만 변형을 주기 때문에.
이게 페이스텔의 특정

이게 좋은점이 암호화 복호화 프로그램이 따로 있어야되는게 아니라 암호화 알고리즘 하나만 있으면 됨..
-> 컴퓨팅 자원의 절약을 하려고 발명한게 아닐까.

10)
DES

64비트인데 왜 56비트이냐
8비트당 1개는 자동적으로 결정되는 그런 의미없는비트.
실질적인 비트는 7*8 = 56비트

11, 12)
자세한 구성은 설명안함..

13)
DES의 안전성

Known plaintext attack을 고려하자

어떤 플레인텍스트에 어떤 키가 들어갔더니 어떤 사이퍼텍스트가 나왔다,
라는 쌍을 공격자가 하나 알게됨. 키는 모르고

영어에서 뭔가 dear, sincerely, … 이렇게 자주쓰이는 부분은 쌍이 알려지기 쉽다.
플레인텍스트 사이퍼텍스틀 알고있고, 키를 맞추는게 공격자의 목적.
=> 가능한거 다해봄그냥. 56비트 키니까 2의 56승가지

공격자는 키를 다 하나하나 대응해서 맞춰본다.
2의 56이라는 숫자는 7.2x10의 16승
이는 얼마나 큰 크기인가.
초당 10억개의 디크립션을 할 수 있는 컴퓨터가 있다면(매우 고사양컴퓨터) 평균적인경우 1.125년이 걸린다. 최악의경우엔 2.25년

길면길고 짧으면 짧은..

20몇년전얘기임
미국정부가 DES가 안전하다고 주장
DES를 공격하는 전용 하드웨어 머신을 만듬. des cracker.
-> 하루안에 성공시킴.
미국정부에서 표준을 새로만듬. AES

키의 길이가 2배가 되었다. -> 2의 72제곱배 만큼 안전한것
키 길이도 길게쓰면서 구조도 안전하게.
그래서 당분간은 aes가 깨지지 않을거라고 생각한다..

des가 키의 공간이 작은게 문제였는데, 그거도 문제지만 통계적인, 구조적인것도 숨겨야한다
근데 aes나 페이스텔 사이퍼는 구조적으로 문제가 있다고 여겨지지는 않는다.

aes는 페이스텔 사이퍼가 아님.
aes는 spn이라는 구조. 그냥 다른 옵션이라고 생각하면됨.

챕터 3 
7,21,22,31,32,33 스샷 필요

