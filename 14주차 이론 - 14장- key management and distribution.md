# 14주차 이론 - 14장. key management and distribution

2)
콘텐츠

공개키를 안전하게 전달하는 방법
쭉 발전해오다가 마지막에 public-key certificate가 된것. 우리는 이것만 다룰것

3)
공개키를 안전하게 전달하는게 왜 중요하냐

10장에서 나왔던 DH에서의 MitM 공격
-> 키의 confidentiality와 무관하게 authentication, integrity를 확인할 수 없어서 생긴일
이것을 해결해주는게 오늘의 내용

4)
공개키를 나눠주는 방법 중에 가장 단순한 방법
1.
원래의 방법처럼 그냥 모두에게 공개키 줌.
그러면 위와같이 MitM attack 당할 수 있음.

안좋은 방법

5)
2.
누구나 접근할 수 있는 디렉토리 서비스(일종의 게시판)를 이용하면 어떻겠느냐.

디렉토리 자체에 대해서 안전성이 보장되지 않으면, 이 역시 안전하지 않다.
앨리스의 ID를 쓰는데 진짜 앨리스인지, 앨리스인척 하는 건지

6)
3.
더 안전하게 할 수 있는 방법.
믿을 수 있는 기관(Public-key Authority)에 요청하는 것.

(1) 처음에 앨리스가 기관에게 타임스탬프와 요청을 보냄.

(2) 기관은 해당 요청, 타임스탬프에 대한 밥의 공개키를, 기관의 개인키로 서명(E)하여 앨리스에게 전달

(3) 앨리스는 기관의 공개키가 있으면, 기관의 개인키로 서명된 내용을 확인할 수 있겠다.
밥의 공개키를 이용해서 메세지를 인크립션(E)해서 보낸다
IDA : 앨리스의 아이디
N1 : Nonce1. replay 방지용

(4) 밥은 IDA 라는 사람이 나랑 통신하기를 원하는 구나, 파악하고
기관에게 IDA 에 해당하는 공개키가 뭐냐, 요청

(5) 기관은 그 요청에 대해 앨리스의 공개키를, 기관의 개인키로 서명을 해서 준다.

(6) 밥이 기관의 공개키를 가지고 있으면, 개인키로 서명된 내용을 확인할 수 있겠다.
-> 앨리스의 공개키를 알게 되었다.
N1을 정상적으로 해석하고, N2를 붙여서 앨리스의 공개키로 인크립션하여 앨리스에게 보냄

(7) 내가 요청한 공개키의 주인인 밥이, 개인키를 이용하여 정상적으로 나의 메세지(N1)을 풀어보았다는 것을 확인,
N2를 밥의 공개키로 인크립션하여 전송
-> 밥은 개인키를 이용하여 풀어볼테고, 저사람이 앨리스가 맞구나 상호확인

이 통신과정에서 문제는?
앨리스도 밥도 기관(Publick-key authority)의 공개키를 알아야 기관이 서명해주는 것을 그 공개키를 이용해서 확인할 수 있을 것.
이 문제는 아직 해결이 안된다.
그런데 이 문제는 잠시 후 에 이야기할 인증서가지고도 해결이 안된다.

또 한가지 문제
앨리스와 밥이 비밀통신을 서로 원하는 상황인데 그 때마다 기관에게 물어봐야한다는 것.
그럼 기관은 항상 온라인으로 대기하면서 서비스를 실시간으로 제공해줘야한다는 문제

앨리스가 받은 것은, 밥의 공개키가 이것이 맞다 라는 사실을 기관이 서명해주는 것을 받음.
잘 생각해보면 그것을 기관이 줄필요없음. 밥이 그냥 주면된다. 반대도 마찬가지겠다.

7)
4.
비유를 통해서 말하면 이런것.
앨리스와 밥이 계약을 하려고한다. 상대방의 신원을 확인하고 싶다.
-> 동사무소가서 이 사람이 밥입니까, 확인하는게 아니라 서로 상대방 신분증 확인하잖아.

따라서 public-key certificate, 즉 인증서를 이용하면 이것이 가능해진다.
즉 내가 내 신분을 확인할 수 있는 증빙을 들고다니다가 상대방한테 준다, 는 개념

public-key certificate는 인증기관(public-key authority)이 개입되는건 같으나,
그 authority가 해주는 것이 실시간으로 공개키에 대한 요청에 답을 주는 것이 아니라,
앨리스를 기준으로, 내 공개키가 맞다는 것을 확인해주세요(IDA + 타임스탬프 + 공개키)를 기관의 개인키로 서명을 받은 결과로 -> 앨리스의 신분증 CA 가 만들어 지는 것.
신분증에 공신력있는 기관의 직인이 찍혀져 있는 느낌
이 과정은 실시간이 아니라 자기 편할 때 아무때나 해서 받아놓으면 되는 것.
또 앨리스와 밥이 통신할 때는, 서로 상대방의 신분증에 해당하는 certificates를 교환하면 된다.
-> 그렇다면 온라인으로 항상 기관에 확인받아야할 필요가 없어졌다.

앨리스나 밥이 certificates를 받아서 막 줘도되느냐?
-> 어차피 기관의 개인키로 서명이 된것이기 때문에 내용조작할 수 X

certificates를 교환하면 역시나 같은 방법으로 기관의 공개키를 이용하여 확인하면, 상대방의 공개키가 맞구나 확인할 수 있는것.

8)
certificates을 가능하게 해주는 것.
X.509라는 certificates 표준

public-key crpytography과 digital signature에 기반
알고리즘은 강요하진 않지만 RSA를 가장 많이 사용

각 certificate은 특정 사용자의 공개키와 ID의 쌍이 들어있다, 믿을 수 있는 certificatiaon  authority의 개인키로 전체 내용이 서명된 형태로.

그럼 authority의 공개키가 있어야 서명확인이 가능할텐데, 그것은 어떻게 할것이냐. 아직 설명안함. 뒤에서 설명할것

9)
Public-key certificate의 대략적인 모식도

10)
조금 더 구체적으로
certificate이 담고있는 내용들

버전, 시리얼넘버, 유효기관 …
Signature algorithm : 어떤 알고리즘으로 서명할거냐. RSA로할꺼냐 ECDSA가지고 할거냐 등
Issuer : CA의 정보
subject : 신분증 주인의 정보
공개키…
등등 이들어있다.

이거 전체에 대해 서명을 해주는 것

11)
X.509 표준 포맷

위의 Signature algorithm 은 이 전체를 CA에서 서명할 때 어떤 알고리즘을 썼냐,
Subject에서의 algorithm은 앨리스가 이 공개키를 어떤 알고리즘에 쓸 것이냐에 관한것.

certificate의 유효기간이 다 되지않아도, 개인키가 유출되었다거나 그러면 사용이 불가능 할 수 있음 -> certificate을 취소(revocation)할 수도 있다.

12)
이 인증서를 이용해서 어떻게 MitM attack을 막는지

PUA, PRA는 A가 가지고 있는 개인키-공개키쌍,
XA, YA는 해당 세션을 위한 개인키-공개키쌍

C : 기관의 공개키로 서명한, A의 정보와 A의 공개키(PUA)

Z : A의 개인키(PRA)로 서명한, A의 정보와 이번 세션을 위한 A의 공개키(YA)

YA를 B에게 전달하는 것이 목표.

YA, C, Z를 B에게 보냄

B는 기관의 공개키를 이용해 C를 풀어봄 -> A의 공개키 확인. PUA를 믿는다.
그리고, PUA를 이용하여 A의 개인키로 서명된 Z를 풀어서 YA를 얻는다.

Darth가 공격을 하려면
C를 위조 또는 Z를 위조해야하는데, 기관의 개인키나 앨리스의 개인키가 필요하기 때문에 불가능

13)
이런 인증서가 가지는 성질

- CA의 공개키를 알고 있는 누구나 상대방의 공개키를 확인할 수 있다.
- CA의 이외에는 certificate 만들거나 변경할 수 없음

CA의 개인키 때문에 certificate이 위조가 안되니까 아무나 볼 수 있는 디렉토리에 막 놔둬도 상관없고, 이 사람 저사람에게 막줘도 상관없다. 안전성을 유지하려 안해도됨

한가지 문제점은 CA의 공개키를 가지고 있어야 이것이 가능하다는 것.

14)
반대로 얘기하면, CA의 공개키가 없으면 인증서가 확인이 안된다.

X<<A>> : X의 개인키로 A의 공개키를 서명해줌 -> 즉 X가 A에게 인증서를 발급해줌.

만약 우리나라에서 상대방의 신분을 확인하려면, 우리나라의 공공기관이 인증해준 신분증이 있으면 되는데, 미국에서는 우리나라의 신분증의 확인이 어렵다. 이런 상황

A와 B가 직접적으로 공유하는 CA가 없는 상황

PKI(Public-key infrastructure)구조인 CA Hierarchy를 이용.

A는 X를 믿는다(X의 공개키를 가지고 있음), X가 A를 인증해줌
X는 W를 믿는다. = W가 X를 인증해줌
W는 V를 믿는다. = V는 W를 인증해준다.
V는 Y를 인증해준다.
Y는 Z를 인증해준다.
Z는 B를 인증해준다
-> 이러한 trust chain 구조를 이용해서 인증서 관리를 해준다

15)
인증서와 인증서의 계층구조사례

https : 웹브라우저를 보호하기위해 TLS를 이용하여 쓰는 프로토콜

크롬 웹브라우저 기준
보안설정에 보면, 인증서에 관한 내용을 자세히 볼 수 있다.

발급대상 : 인증해준 기관
발급자 : 신분증 주인

여기서는 발급자와 발급대상이 둘다 CA. 여러 chain을 거치는 것

특이한 점은 루트 인증서는 발급대상과 발급자가 같다.
즉 공격자가 본인의 공개키와 개인키를 이용해 루트인증서다 라고 말하면,
본인의 개인키로 서명된 내용을 본인의 공개키로 풀 수 있고, 그 내용안에는 본인의 공개키가 있는, 이런 상황이 가능하다.
![14주차 이론 - 14장- key management and distribution](images/14주차%20이론%20-%2014장-%20key%20management%20and%20distribution.png)

-> 모순적인 구조이다.
그러나 이런 루트기관인증서는 보통 OS나 브라우저를 설치할 때 자동적으로 설치되는 인증서이다.
따라서 웹서핑 하다 함부로 루트인증서 설치하면 안되겠다.
왜냐하면 그 루트인증서에 들어있는 공개키는 내가 믿는거니까 그거에 맞는 개인키로 서명된 것은 다 믿어버리게 되는것..

16)
공인인증서.

인터넷진흥원(KISA), 전자서명인증관리센터(KCAC)

17)
우리나라의 이전 전자서명법은,
돈이 오고가는 경우에 공인인증서가 필요했다. 그러나 전자서명법이 개정되면서 다른 수단들도 제공되고 있는 상황. 공인인증서가 없어진것은 아님. 이름도 공동인증서로 바뀜.

이 공인인증서를 쓰는 과정이, 지금까지 배웠던 여러가지 암호기술의 집합.

그렇기 때문에 이 과정을 살펴보는게 의미있다.

…

“이체실행”과 같은 중요한 과정이 진행될때,
사용자가 입력하는 공인인증서 암호를 이용하여 전자서명 진행
어떻게?
우리나라 전자서명에는 보통 RSA이용
2048비트 모듈러스 사용 -> 개인키도 2048비트
-> 256B인데, 사용자가 256글자를 다 외우고 있을 수 없음.
따라서 인증서가 d를 포함하여 personal identification information의 형태로 인코딩된 후 암호화되어 PC(HDD)에 저장된다.
이 암호화는 보통 대칭키 암호 사용, AES경우 128비트 -> 16B
따라서 사용자가 이 16글자를 외우고 있는 것이고,
대칭키암호는 이 패스워드 기반의 암호화를 사용하게 되는데,
패스워드를 AES의 key로 바꾸어주는 함수를 이용해서 K로 바꾼 후 암호화.

즉 내가 이체실행을 위해 공인인증서 패스워드를 입력했다.
-> 대칭암호의 키로 바꾸어주는 함수에 의해 K로 변환
-> 이 대칭암호의 키로 H/W에 저장된 d가 포함된 인증서를 복호화
-> 이 d를 이용하여 RSA 전자서명을 하는것

인증서 파일이 유출되는 경우 패스워드에 의해 암호화 되어있으나, 사람이 만든 패스워드이므로 패스워드 추측 공격에 의해 개인키가 복원이 가능 하다.
-> 따라서 RSA 2048비트의 안전성을 제공하는게 아니라, 딱 패스워드만큼의 안전성을 제공하게 된다. 

18)
요약

 

