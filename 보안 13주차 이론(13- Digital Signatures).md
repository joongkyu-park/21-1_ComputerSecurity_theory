# 보안 13주차 이론(13. Digital Signatures)

2)

3)
전자서명의 특성과 요구조건

특성
- 누가 무엇을 보내는지 확인함 + 추가로 언제보냈는지 확인도 가능 -> authentication
- 서명이 생성될 때 그 당시 메세지 내용에 대한 확인 -> integrity
- 분쟁이 생겼을 때 제 3자에 의해서 해결되게 할 수 있다 -> not repudiation

요구조건
- 보낸 사람이 부인할 수 없도록 해줘야함 개인키가 없으면 위조할 수 없도록해야함
- 서명을 생성하는 것은 쉬워야함(계산이 비교적 간편해야함)
- 서명을 확인하는 것도 쉬워야함
- 개인키가 없으면 서명생성하는게 어려워야함 전자서명이 이미 있는 상황에서, 있는 서명을 이용해서 새로운 서명을 만들어내는 것도 어려워야함 메세지가 있을 때 전자서명을 가짜로 만들어내는것도 어려워야함

당연한 얘기들임

4)
전자서명의 기능을 도식화

지금은 밥이 서명을하고, 앨리스가 서명을 확인하는 과정

![보안 13주차 이론(13- Digital Signatures)](images/보안%2013주차%20이론(13-%20Digital%20Signatures).png)

RSA를 전자서명과 비교했을 때.

그러나 모든 전자서명이 이렇지 않다.

5)
새로운 서명알고리즘들은 discrete 로그 문제에 기반하고 있다.
(RSA는 정수 소인수, factoring 문제에 기반했었다.)

그래서 잠깐 복습하겠다.

새로운 개념. Subgrop
모듈러스 p가 19인 예.
2 같은 것이 generator인 ⍺가 되겠다. 제네레이터는 유일하지않고 여러게 있을 수 있다.

2^3 = 8 같은 경우를 생각해보면
![보안 13주차 이론(13- Digital Signatures)-1](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-1.png)

이러한 매핑관계가 있겠다.
2일 때는 원소개가 18개인 group이었는데,
8일 때도 사실 원소가 6개인 group이라고 볼 수 있다.

서브그룹의 크기는 전체그룹크기(여기선 18)의 약수여야함.
7인 경우는 크기가 3인 서브그룹을 만들 수 있겠다.

p-1의 약수인 q의 크기가 되는 서브그룹을 만들 수 있다.

이걸 왜만드냐.
6)
왜 이렇게 서브그룹 같은 것을 쓰는가
discrete log문제(DLP)와 modular exponentiation의 관계를 보자.
x를 주고 a^x mod p를 계산하는게 modular exponentiation 문제,
a^x mod p의 값을 주고 x를 찾는게 DLP
x는 p-1까지 될 수 있다.

지수연산의 복잡도는 2가지 요소가 있다
modular exponentiation는 곱셈의 반복으로 되어있다.
- 곱셈의 개수가 지수의 올라가있는 x의 비트길이에 대체로 비례한다는 특징 이있다.
- 각각의 곱셈의 복잡도는,모듈러스 p의 비트길이의 제곱과 대체로 비례한다

x는 최대값이 p-1 이니까
결국 총 p의 비트길이의 3제곱 정도의 복잡도가 들게된다. 

따라서 효율성 측면을 보면 작은 p를 쓰는게 유리
큰 p를 쓰면 성능은 떨어지지만 안전성은 올라가겠다

7)
DLP를 푸는데 크게 2가지 계열의 알고리즘이 있다.

- GNFS 모듈러스 p로 구선되는 프라임 필드의 대수적인 성질 이용. p의 비트길이가 뭐냐에 따라 복잡성 결정 p가 3072비트라면, p가 프라임이라는 성질을 잘이용하여서 2^3072번이 아닌 2^128정도의 공격만으로도 가능
- Pollard rho 해쉬의 충돌찾는 것처럼 birthday paradox를 이용 DLP뿐만아니라 타원곡선DLP에도 적용 지수의 x가 몇가지 종류가 가능하냐, 와 복잡성이 관련 2^256의 후보가 있다 -> 2^128개 정도의 공격만으로도 가능

8)
따라서 정리하면,
같은 안전성을 가지면서 계산을 좀더 빨리하는 방법을 찾은것.
위의 두가지 공격에 대한 대응책 사이에 적당한 대응책을 찾은것

p는 크게 하되, 지수에 올라가는 모듈러스q는 적당한 크기로 잡아도 상관없다.
왜냐하면 q자체가 mod p에 관련되는 GNFS의 복잡도에는 영향을 미치지 않기 때문

따라서
![보안 13주차 이론(13- Digital Signatures)-2](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-2.png)

이렇게 바꾸게된다.

전체적인 계산은 여전히 mod p이기 때문에 GNFS의 복잡도를 낮추지 않는다
x를 x mod q로 낮추긴 했지만, q는 어쨌든 2^256정도의 크기이기 때문에 pollard rho의 공격에도 어느정도 안전하게 할 수 있다.

효율성은 어떻게 되느냐
개별 곱셈의 복잡도는 여전히 p의 비트수의 제곱에 비례하는 것은 똑같은데,
곱셈의 갯수가 줄어든것.
![보안 13주차 이론(13- Digital Signatures)-3](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-3.png)

9)
몇 가지더
- 타원곡선은 더 작은 키를 쓰는게 가능 한 이유 GNFS에 대한 공격(mod p에 관련된)은 타원곡선에 적용이 안됨. 가능한 지수가 몇개냐만 타원곡선 공격과 관계됨.이게 ECC가 그냥 DL기반보다 더 효율적인 이유

- 위에서 사용되는 q는 소수여야함. 그게 아니라면, pohlig-hellman이라는 공격에 의하여 각개격파느낌으로 쉽게 뚫릴 수 있다.

10)
본론으로 돌아와자
책에 없지만 요즘 좀 핫한 주제라 한다
Schonorr 알고리즘(전자서명을 위한 알고리즘)

Schonorr Identification(Identification이나 authentication이나 같은 뜻)
이것은 Zero knowledge proof(ZKP)의 일종. 요즘 핫한 주제

이건 일종의 challenge-response 기반의 사용자 인증.
challenge-response가 뭐냐
prover(client)가 있고 verifier(server)가 있다.
사용가자 서버를 사용하기위해 회원임을 증명하는 상황.
회원가입을 했다. id ~~, pw 7 이후에 로그인할때 : id ~~인데 pw 7야.
근데 공격자가 스니핑을 하다가 패킷을 알아내게 되면, 같은 패킷을 재사용해서 인증을 할 수 있을 것이다.

따라서 서버 쪽에서 challenge를 준다.
서버 쪽에서 2를 넘겨주면 사용자는 7+2 해서 9를 넘겨준다.
매번 다른 challenge른 넘겨준다
따라서 사용자가 response하는 패킷을 캡처해서 단순히 재사용한다고 해서 공격에 성공할 수 없게 한다.

이렇게 단순하게 하면 몇가지 문제가 있다.
- 서버쪽에서도 계산해야하니까 비밀번호를 해쉬값으로 저장하는게 아니라 원본으로 저장해야한다.
- 위와 같이 너무 단순한 로직이면 스니핑만 하더라도 2라는 challenge가 오면 9를 주면 될 것이다.. 쉽게 알 수 있다.

따라서 이것보다 조금더 안전하게 구성해야하는데,
Schonorr Identification에서는 DLP문제를 기반으로 구성하게 된다.

앨리스가 prover, client
앨리스가 키 pair를 가지고있다
개인키 : a
공개키 : v = ⍺^(-a) mod p: 몇가지 이유로 -a를 이용하지만, 본질적으로 a제곱과 차이없다

밥이 verifier, server

앨리스가 자기 신원을 증명하려는 상황

처음에 랜덤한 0~q-1사이의 k를 뽑는다
앞에서 한거처럼 지수는 mod q(서브그룹)로 할거고
exponentiation의 결과는 mod p로 할거다

지수에 올라가는 값은 mod q 범위에서 선택.
그걸 실제로 ⍺^k 하고 mod p 로 계산 -> 그것을 γ(감마)라고 하자.
이 때 k를 일시적인 개인키로하고, 일시적인 공개키를 계산했다고 볼 수 있다.
이걸 상대에게 보냄
밥은 적당한 범위에서 challenge를 던진다
앨리스는 
![보안 13주차 이론(13- Digital Signatures)-4](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-4.png)

이와 같은 계산을 하게 된다. r은 받은 챌린지

그 y값을 밥에게 주면
![보안 13주차 이론(13- Digital Signatures)-5](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-5.png)

이 값을 확인해볼것이다.

만약 앨리스가 밥이 기대하는 그 사용자가 맞다면,
밥이 알고 있는 공개키(v)에 맞는, 지수에 해당하는 개인키 a를 알고있는 사람이어야한다.

즉 -> 밥이 알고있는 공개키에 해당하는 개인키를 알고있는 그 소유자가 맞냐를 판별한다.

만약에 개인키 a를 모르면, y를 제대로 계산할 수 없다가 가정.

![보안 13주차 이론(13- Digital Signatures)-6](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-6.png)

에서,
⍺^y = ⍺^k * ⍺^(ar) mod p 이고,
v^r = ⍺^(-ar) mod p이므로,
두 개를 곱하면 상쇄되어
γ = ⍺^y * v^r = ⍺^k이 될것인데,
γ는 애초에 ⍺^k mod p 였다.

앨리스의 계산과정에서 개인키 a가 쓰이니까, 그걸로 확인한다는 것

11)
Schonorr Identification의 성질
여기서 원했던 것은 챌린지-리스폰스 기반의 인증을 하려고 했던것

앨리스 입장에서는, 밥한테 자기 패스워드를 그냥 알려주기는 싫었다.
따라서 밥에게 공개키같은 정보를 미리주고,
밥이 하는 질문에 앨리스가 답을 하는, 간접적으로 자신의 지식을 증명하는 방식으로.

앨리스 입장에서 걱정되는것.
밥이 하는 질문에 내가 계속 답을 하다보면,
원래는 밥이 몰랐던 정보(자신의 개인키)를 조금씩 누적해서 알게되지않을까
질문 여러번을 조합하다보면 개인키를 알게되지않을까?
=> 결론적으로 이게 안된다
그래서 zero-knowledge proof이다.
증명은하는데, 밥한테 어떤 지식도 주지 않는다.

개념적으로 이해해보자.
실질적으로 제3자입장에서 어떤일이 일어나는지 보면
앨리스 -> 밥 : 감마 줌
밥 -> 앨리스 : r줌
앨리스 -> 밥 : y를 던짐

밥 입장에서 감마, r, y 이 값들을 조합하면 유용한 정보가 나오느냐.
그게 아니라는 것.
결국 밥이 알고자하는것은 세 값들의 관계식인데,
![보안 13주차 이론(13- Digital Signatures)-7](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-7.png)

저 세 값이 위 식처럼 맞아 떨어진다는 것을 알게 되는건데,

이 등식이 성립되는 감마,r,y 세 개의 순서쌍을 밥이 가지게되면, 밥이 혼자서는 알 수없었던 유용한 정보를 알게 된것이 아니냐 할 수 있는데.

이 세 개의 순서쌍이 밥혼자서도 충분히 만들 수 있는 값이다.
순서만 좀 바꾸면됨

![보안 13주차 이론(13- Digital Signatures)-8](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-8.png)

r먼저 랜덤하게 선택
y를 0에서부터 q-1범위 내에서 랜덤하게 선택
그러고나서 역으로 계산하여 감마를 만들어내면 됨.

결과적으로 말하면,
제 3자 입장에서
밥이 혼자서 r, y를 만들어서 감마를 만들어낸건지,
아니면 밥이 r을 주고 앨리스가 거기에 답을해서 준 y로 감마를 만든건지 구분이 안가는 거임
이 두상황이 본질적으로 차이가 없다는 것
그래서 밥이 어딘가에서 앨리스인척 할 수 있다던지, 부분적인 정보를 가지고 유용한 일을 할 수 있지 않다는 것.

이게 zero-knowledge를 보이는 방법.

12)
그런데 왜 책에도 없는 이런걸 설명하고있냐..

ZKP에 예전엔 사람들이 관심이 없었지만 최근에 관심이 늘게되었다.

2018년에 MIT에서 뽑은 10개 기술중 1개로 선정.

Perfect Online Privacy
예를 들어 내가 18살이 넘었다는 걸 인증하고싶은데, 내 생년월일은 보여주고 싶지않다.
또는 비자같은거 발급받을 때 은행잔고증명해야하는데, 어느 은행에 돈 얼마있는지 보여주고 싶진 않고, 어느기준 이상 돈 있다 그거만 증명하고 싶다.

정확히 필요한것만 증명하고, 그 이외에 필요없는 것들은 증명하지 않겠다
-> privacy. 자기의 정보를 자기가 통제하는것

이것을 위해서 널리 쓰이고 있는 수단이 zero-knowledge proof 이고,
그중 가장 간단한게 위에서 본 Schonorr Identification.

13)
ZKP가 실용적인 부분에서 최근에 각광을 받기 시작했지만,
학문적인, 이론적인 관점에서 여러 중요한 역할도 했다.

14)
지금까지 슈너 아이덴티피케이션, ZKP 등을 이야기 했었는데
다시 본론으로 들어와서,
Schnorr identification을 간단하게 전자서명으로 바꿀 수 있다.

- Schnorr identification은 intertactive한 proof 프로토콜이다
- 이러한 interactive proof 프로토콜을 전자서명으로 바꾸는 일반적인 방법이 있다. Fiat-Shamir heuristic. Fiat-Shamir가 만든 방법.

여기선 interactive한게 포인트다.
만약 공격자가 밥이 주는 r값을 미리 알고있다면,
위에서 했던거와 같이 역순으로 감마를 만들어서,
그 감마를 밥한테 주면 r을 이미 알고있으니까 그에 해당하는 y를 줘서
결과적으로는 개인키를 모르는데도 인증이 된것
=> 따라서 밥이 r을 랜덤하게 잘 주는것이 중요한 포인트

근데 이제 할건 interaction이 없이 할것.
어떻게?
인터랙션이 없다는 것은, 밥의 질문없이 앨리스가 혼자 무언갈 밥한테 주면 끝- 나는 상황.

밥한테 질문받을 r을 자기나름 대로 계산.
물론 자기가 계산을 하지만, 마음대로 조작할 수 없게 해야 아까와 같은 공격이 발생하지 않겠다.
메세지를 넣고 위에서 계산된 감마를 넣어서 
![보안 13주차 이론(13- Digital Signatures)-9](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-9.png)

이와 같이 r을 만든다.

그럼 위와 같은 공격을 할 수없겠다.
이렇게 하면 r을 먼저 만들고 그 다음에 감마를 만드는 역순을 막을 수 있으니까.
이 때의 해쉬함수는 일종의 난수발생을 하게 된다고 볼수 있다.

결국은 메세지에 의존해서 r이 생성되니까, 메세지에 의해서 무언가 변화는 과정을 만들 수 있으니까 이걸 서명으로 쓰겠다는 것.

이제 밥 입장에서는 감마와 y를 가지고 proof 해야한다.
![보안 13주차 이론(13- Digital Signatures)-10](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-10.png)

다음과 같이.

만약에 앨리스가 개인키 a를 모르는 상황이면, 정상적인 y를 만들수 없다.
y계산에 a가 들어가니까

물론 r을 자기나름대로 컨트롤 할 수 있으면 시뮬레이션 하는 거처럼 감마를 만들고 그럴 수 있지만, 지금은 감마먼저 정하고 내 마음대로 컨트롤할 수 없는 hash에 의해서 r이 만들어지는 상황이라 마음대로 조작할 수 없기 때문에
private키를 알고있는 앨리스만이 y를 생성해낼 수 있다 

사실은 최종적인 Schnorr signature은 조금 변경이 있다.
위의 1번과 2번 과정을 바꿈
![보안 13주차 이론(13- Digital Signatures)-11](images/보안%2013주차%20이론(13-%20Digital%20Signatures)-11.png)

15)
요약

