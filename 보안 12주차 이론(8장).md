# 보안 12주차 이론(8장)

ch8. 난수발생

2)
컨텐츠

3)
난수

난수를 어디다 쓸꺼야

암호나, 네트워크 프로토콜(보안관련된)

지금까지 우리가 했던 것들 중에서도 쓰였었다.

4)
직관적으로 난수냐, 그렇지 않냐 구분할 수 있다.

![보안 12주차 이론(8장)](images/보안%2012주차%20이론(8장).png)

어떤게 더 난수같나? 직관적으로 아래쪽이 더 난수같다.

이것을 정형화된 방법으로 설명해보자.

난수가 만족해야할 두가지 성질

Randomness
- 유니폼한 분포 비트라고 했을때, 0과 1의 빈도가 비슷해야함
- 인디펜던스 앞 시퀀스가 뒤 시퀀스한테 영항주면안됨

	Unpredictability(지금껄보고 뒤에걸 예상하면안됨)
	전체 생성 시퀀스 중 일부를 알아도,
	그 이후의 것을 알 수 없어야함 -> forward unpredictability	
	그 이전의 것을 알 수 없어야함 -> backward unpredictability
5)
난수처럼 보이는 의사난수. 우리가 보통 만드는 난수

deterministic한 알고리즘.
진짜 난수 아니다.

그러나 알고리즘이 충분히 잘 설계된다면, 결과로 나오는 시퀀스가 난수인지 판별인지 아닌지 판단할때 난수로 판단될 수 있다.

6)
우리가 얘기하고 있는 것은 PRNG
시드 넣고 deterministic한 알고리즘 돌림

PRF - PRNG와 같은데, 128-AES처럼 비트 정해주는것(?)

TRNG - 진짜난수. 내가 컨트롤할 수 없는 물리적인, 자연계에서 발생하는 변화들을 모아서 바이너리형태(디지털)로 바꾸는것

진짜난수를 그대로 쓸 수 있으면 좋지만, 문제는 생성되는 양이 제한적이라 원하는 만큼 효율적으로 만들어지지 않는다. 따라서 조금씩 나오는 걸 모아서 -> PRNG의 seed로 넣어서 뻥튀기 시켜서 사용한다.

7)
TRNG
진짜로 랜덤.
소스로 받아서 바이너리 형태로 바꾸어준다.

인풋으로 받는게 대부분 아날로그 소스이다. = entropy source
이걸 컴퓨터의 physical enviroment가 모아서 사용한다.

아닐로그 소스를 바이너리 아웃풋으로 컨버젼 해주는 것이 TRNG가 하는일

경우에 따라선 bias를 없애기 위해 추가적인 작업을 해줄 때도 있음.

8)
PRNG 보충설명
진짜 랜덤은 아님.

주로 TRNG로부터 만들어지는 seed값을 이용하게 된다.

seed라고 하게되는 fixed 밸류를 인풋으로 받고
deterministic한 알고리즘을 돌려 비트시퀀스를 아웃풋으로 낸다.

PRF
정해진 길이의 아웃풋을 내되, 랜덤하게 만들어서(의사랜덤).

PRNG와 PRF는 같지만, 그냥 아웃풋길이가 고정되어있느냐 아니냐의 차이

9)
PRNG 요구되는 성질

시드를 공격자가 알면 끝나고,
시드를 모르면, 알고리즘을 알더라도 아웃풋을 몰라야한다.

즉 Randomness, Unpredictability, 충분한 길이의 시드

10)
Randomness, Unpredictability을 좀 더 디테일하게 따져보자

1111111은 왜 랜덤처럼 보이지 않고, 2354392 같은 수는 왜 랜덤같아보이느냐.

15가지의 테스트중 몇개 설명

- Frequency test : 비트시퀀스의 경우 0이나 1로 한쪽으로 몰리면 안된다.  예) 만약 100bit 시퀀스를 만든다 0이 50개, 1이 50개 일때가 유니폼하겠다 그럼 0이 48, 1이 52면 뭐지? -> 이정도까진 오케이.. 그럼 0이 10개, 1이 90개 -> 이런일은 확률이 굉장히 낮겠다.. 거의 일어나지 않는일  그렇다면 기준이 있어야하겠다. -> 이런기준을 정해놓은 것
- Runs test : 0 또는 1이 연속해서 몇번 나왔냐  예) 1이 연속 2~3번은 나올 수 있지.. 근데 1이 연속 10번 나왔다? 이건 좀..  이런 연달아서 나오는 비트가 어디까지 허용이 될 것이냐, 기준을 정해놓음
- Maurer’s universal statistical test 시퀀스가 압축이 잘 되냐 안되냐  시퀀스의 규칙이없어서 압축이 안됨. 무손실 압축알고리즘을 돌렸을때, 압축이 잘된다 -> 난수아니다  예) 2354392 는 잘안외워진다… 규칙이 없어서 압축해서 외울수 없기때문 1111111 는 잘외워진다. 압축이 잘되는 것이기 때문

11)
Seed Requirements

seed는 secure해야하고 유추가능하면 안된다.

seed 자체는 rand이어야한다, 경우에 따라서는 수도랜덤인 경우도 있다

일반적으로는 TRNG에 의해서 생성

12)
이러한 조합이겠다.

결과로나온 Pseudorandom bit stream이 난수테스트를 받는것

13)
PRNG 알고리즘을 어떻게 디자인 할거냐
두가지가있다

1. 있는 암호 알고리즘을 잘 개조하자 블록사이퍼를 잘 활용하면 된다. asymmetirc ciphers(공개키암호)나 해쉬함수, message authentication code등도 활용가능 그러나 공개키암호는 너무 느려서 잘안씀
2. 난수생성용으로만 생성한 알고리즘

14)
Linear Congruential 제네레이터

난수발생용으로만 만든 알고리즘
안전하지 않음

피드백으로 연쇄적으로 숫자를 생성하는 방법

안전하지 않은 이유 -> 방정식을 만들 수 있음
공격자가 연달아서 생성된 시퀀스를 알고있음. m, a, c 같은 파라미터는 모름

모르는 미지수가 2개이므로 연립방정식 풀면된다. 모듈러스때문에 간단하지 않지만.
![보안 12주차 이론(8장)-1](images/보안%2012주차%20이론(8장)-1.png)

따라서 이것은 키생성이나 암호 용도로 쓰면안된다.
다른거 난수확인용도 정도로 사용

15)
그럼 안전한거 만들라면 어떻게 해야하나

다음은 NIST표준에 의한 안전한 난수 발생기 목록들

DRBG = PRNG

2012는 hash기반, HMAC기반, CTR기반, 타원곡선 기반이 있었는데
2015에서는 타원곡선이 빠졌다. 문제를 발견했기 때문. 여담이 있다.

16)
블록사이퍼 기반 PRNG

주로 자주사용 되는것
CTR모드, OFB모드

17)
CTR모드, OFB모드의 난수발생기 기본적인 구조

18)
카운터 기반의 DRBG

- 카운터 기반의 deterministic random 비트 제네레이터
- 니스트 표준
- 널리 사용되고 있음. intel기반의 프로세서에서도 사용.
- 엔트로피 소스가 있다고 가정한다. 그 소스로부터 입력을 받아 DRBG를 돌려 수도랜덤비트를 만들어낸다
- 블록사이퍼 뭐써야되냐. -> 안전한거 아무거나 쓰면 된다. 3DES, AES, 128 …. 난수발생은 사이퍼 안전성이랑은 다른얘기

19)
그림예시

reseed는 알고리즘 몇번이상 돌리면 seed를 초기화
그거를 위해 몇번 돌렸는지 counter로 세준다

20)
이 그림은 여러번봤다

21)
스트림 암호를 설계할때는 뭘 설계해야하냐

- 인크립션 시퀀스가 긴 period(같은게 반복되는 싸이클의 주기)를 가져야한다. 진짜 랜덤이면 좋지만, 그렇지 않은 수도랜덤이기 때문에, 시드에 의해 알고리즘 돌리다보면 어느순간 싸이클이 생긴다. 공격자가 이 주기를 모르도록 길어야한다.
- 생성된 key stream은 진짜 난수처럼 보여야한다 -> 난수테스트 통과해야함
- 키 길이는 최소 128비트
- 같은 키길이 쓰면 블록사이퍼만큼의 안전성을 내야한다.

22)
전용 스트림 암호들을 설계해서 쓴다.

RC4

- 키사이즈 가변적, 바이트단위로 암호화
- 아웃풋바이트1개 만드는데 8~16개의 머신 오퍼레이션(8~16클럭)이 필요 -> 굉장히 빠름. 소스코드도 굉장히 간단하다.
- TLS 또는 그의 전신인 SSL 에서 많이 쓰였다. 웹브라우저, 웹서버에서 많이 쓰였다.
- 무선랜 스탠다드에서 쓰이는 WPA 등에서도 쓰였다.

23)
그러나 더이상 안쓴다. 깨졌음.

24)
다른 스트림 암호들.

25)
TRNG는 어떻게 구성할 것이냐

- 어떤 랜덤소스를 가지고 엔트로피소스를 만들어낼것이냐 -소리, 비디오 : 카메라나 마이크등의 화이트 노이즈이용 -디스크가 돌아가면서 생기는 공기의 저항 이용 -ring oscillator : 회로 관련

26)
엔트로피 소스에서 나온것이 bias가 있을 수 있다.

bias를 후처리해서 bias가 없는형태로 만드는것 -> Conditioning

27)
인텔 난수 발생기

2012에 나온 대부분 프로세서에 들어가있음. 하드웨어. 그냥 박혀있는 것

28)
인텔 난수 발생기 구성

ring oscillator : 회로 소자의 인버터(0을 1로, 1을 0으로 바꾸는것)를 홀수개로 겹처놓게 되면, 인버스된 결과가 나오는데, 그걸 피드백으로 주게되면
![보안 12주차 이론(8장)-2](images/보안%2012주차%20이론(8장)-2.png)

이게 이상적인 그래프인데,

![보안 12주차 이론(8장)-3](images/보안%2012주차%20이론(8장)-3.png)

다음과같은 진동이 생기게 된다.

따라서 기대되는 값과 달라서, 1, 0이 랜덤하게 나온다.  이 점을 이용하여 TRNG를 만든다.

컨디셔너 : 자연적으로 1과 0의 분포가 좀 편향(bias)되면, AES의 CBC를 돌려서 bias를 없애준다.

이것을 쓸때는 RDSEED나 RDRAND같은 어셈블리명령을 쓴다

29)
더 자세한 내용.

30)
요약

