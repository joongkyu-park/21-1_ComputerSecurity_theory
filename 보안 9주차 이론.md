# 보안 9주차 이론

지지난주에 했던 AES 복습.
블록사이퍼다.
여러 라운드가 반복되는 형태

키사이즈는 선택가능하고(키 사이즈가 커질수록 라운드도 늘어나고 안전성도 올라간다),
블록사이즈는 128비트로 결정.

128비트 키 기준으로 round는 10개

각 라운드는 4가지의 트랜스폼으로 구성

플레인텍스트 + 키 -> 사이퍼텍스트 (인크립션)
사이퍼텍스트 + 같은키 -> 플레인텍스트 (디크립션)

Ch 7에서는
블록사이퍼를 하나의 블랙박스로 놓고 응용에 따라 다르게 활용하는 것을 배운다.

그전에 우리나라 암호먼저

1)
암호모듈 검증제도
우리나라말고도 다른 나라에도 다있음
국정원 사이트에 우리나라에서 쓰이고있는 암호들이 정리가 잘 되어있다.

…

5)
SEED -> des와 같은 페이스텔 구조
ARIA -> aes와 같은 spn구조
LEA -> ARX구조

Ch 7. Block cipher operation

2)

3)
multiple encryption

des가 깨졌다.
이유 -> 구조상의 문제가아니라 Key가 너무 짧아서.
-> 구조 유지하고 키 늘리는 방법?
=> 암호화를 2번 돌린다. 키를 2개 이용해서.
Double DES

키(56비트 키라고 가정)를 2개를 썼으니까, 공격자 입장에서 보면 키를 2개다 알아야한다.
-> 112비트의 키가 있는것과 같은 효과가 있지않을까?

… -> 그러지 못한다.

4)
Meet-in-the Middle Attack

플레인텍스트와 사이퍼텍스트 쌍이 몇개 알려진 상황 가정.
ex) 이메일같은경우 맨뒤에 sincerely, ~드림, ~올림 같은 것들.

공격자는 키를 알고 싶은 것.
키를 알게되면 게임 끝. (알고리즘은 원래부터 표준으로 알려져있는거고)

플레인텍스트를 안다.
K1이 뭔지 모른다. 
0000..0 부터 ~ 1111…11 가지 2의 56제곱개가 있을텐데
모두 계산해서 서로다른 X들을 만든다.

마찬가지로 K2에 대해서도 진행.
![보안 9주차 이론](images/보안%209주차%20이론.png)

이렇게 되면 총 경우의 수는
![보안 9주차 이론-1](images/보안%209주차%20이론-1.png)

이렇게 되니까 key가 2배로 늘어난거랑 같지않냐! 라는게 double des의 목표
-> 그렇지 않았다.

공격자는 플레인텍스트와 사이퍼텍스트의 쌍을 아니까,
P를 인크립션으로 X로만들고,
C를 디크립션으로 X로 만들었을 때 그 X는 서로 같다는 사실을 이용.
![보안 9주차 이론-2](images/보안%209주차%20이론-2.png)

정상적이라면 X와 X’중에 맞아떨어지는게 한 쌍이 있을것이다.
이렇게 되면 K1과 K2가 어떤것인지 한번에 알게된다.

복잡도,연산량 봐보자.
![보안 9주차 이론-3](images/보안%209주차%20이론-3.png)

인크립션
+ 디크립션
+ X와 X’를 매칭시키기위해 각각 소팅 (복잡도 nlogn) 하므로 비교연산
+ 매칭되는지 비교연산

=> 여튼 2^112 보다는 훨씬 작다.

여기서도 함정이 하나있다.
위의 중간결과들을 다 저장해야한다.
2^56개의 중간결과. 각각이 8바이트. X와 X’에 대해서 하므로 2배.
![보안 9주차 이론-4](images/보안%209주차%20이론-4.png)

-> 100만 테라바이트 필요…

=> 현실적으로 가능한 공격이냐….?

time-memory tradeoff
![보안 9주차 이론-5](images/보안%209주차%20이론-5.png)

(?)

원래 메모리를 전혀 안쓰고 하는 공격
2^112 time 필요 (프로그램 실행 기본적인 메모리 이런거 제외하고…)

밋 인더 미들어택을 했을떄
시간은 2^112보다 훨씬 작다 (대략 56x2^56)
그대신에 메모리가
100만 테라바이트가 필요했다.

-> 둘 다 극단적이다.

가운데 어딘가에서 적절한 방법이 없을까
전체적으로 해야하는 일은 같음. 시간을 쓸거냐 메모리를 쓸거냐 이걸 결정.
![보안 9주차 이론-6](images/보안%209주차%20이론-6.png)

질문)
meet-in-the middle attact에서
매칭되는 쌍이 2개이상이라면..? -> 이 확률은 굉장히 낮다..
또 플레인-사이퍼 쌍을 알고있는게 보통 1개가 아니라서, 다음 쌍도 진행시켜보면 매칭되는 걸 잘 알 수 있다.

그러나 순방향으로 인크립션을 두번하는 경우는 충돌할 수 있는 경우가 많을 수 있다.

5)
트리플 DES
두가지버전. 키를 2가지쓰는, 3가지쓰는.

직관적인 방법.
3번 스테이지 암호화 과정을 거침.

6)
트리플 인크립션.

왜 인크립션-디크립션-인크립션이냐.
어차피 인크립션이나 디크립션이나 본질적으론 같은 메커니즘이라..
하위호환성 때문에 (backward compatibility)
-> 트리플 인크립션에 K를 1가지를 넣고 적용시키면 싱글 DES가 됨.
트리플 DES가 구현되지 않는 시스템(싱글DES만 적용될 수 있는)을 대상으로 적용해도, 최소 싱글 DES가 되게하기위해.
K1=K2=K3이라면 인크립션->디크립션-인크립션 하면 결국 한번 인크립션 되는거니까.
ex)
![보안 9주차 이론-7](images/보안%209주차%20이론-7.png)

키가 2개면 첫번째 키를 3번째에 다시 이용.
키가 3개면 차례차례 키 적용

7)
암호화 알고리즘 쓰임새가 여러가지있는데, 
쓰임새마다 암호화가 조금씩 달랐으면 좋겠다.
-> modes of operation

블록암호에 적용되는 방법, nist에서 표준화한 방법.

대표적으로 5개의 모드가 있다.

8)
mode가 어떤가 알려면
블록사이퍼가 어떤것이었냐 다시 되돌아볼 필요가있다.

플레인텍스트를 같은 크기의 여러 블록으로 자른다.
![보안 9주차 이론-8](images/보안%209주차%20이론-8.png)

쪼갠다음에 블록 하나를 입력으로보고, 키를 또 다른 입력으로 줘서
인크립션을 돌림.

디크립션 때도 블록들을 하나하나 다 디크립션 시켜서 붙이면 plain text가 되는 형태였다.

9)
1. ECB(Electronic CodeBook) mode
입력으로 같은 블록이 들어가면 -> 똑같은 출력블록이 나오는 형태
k는 정해져있음.

10)
이런 문제가 있을 수 있다.

펭귄그림을 암호화해보자.
32bit를 1픽셀로 쓰는게 가장 많이 쓰는 이미지 인코딩 방식
-> 128비트는 4개의 픽셀 가능.
4픽셀당 1개의 블록으로 구성 가능.
블록하나하나다 ECB모델로 들어간다.

-> 같은 입력은 같은 출력으로 나오기 때문에 (k도 다같음)
그림과같이 암호화는 되었다(다른걸로되었다) 그러나,,,, 펭귄으로 보인다.
같은검정은 같은 출력으로 암호화.. 같은 하얀색은 같은 출력으로…

=> code book이기 때문에 발생한 문제.
마치 퍼뮤테이션 싸이퍼에서 알파벳의 통계를 살펴보았듯이.

-> 이전의 폴리알파베틱, 버지니어 사이퍼처럼 같은게 다른걸로 대응 시키게 하자!

11)
2. CBC(Cipher Block Chaining) Mode

키로 인크립션 하기 전에 다른놈이랑 XOR시킨다.

p1을 인크립션한 c1이 있다면, p2와 c1을 처음에 xor 시키는 방식.
p1은 c0(이니셜 벡터)라는 걸로 xor.

-> 같은 값이어도 다르게 나온다.

얘는 독특한 특성이 있다.
플레인텍스트의 한비트가 삐끗해서 오류가났다. 
암호화 과정이 AES처럼 몇개의 라운드를 거친다면, -> 산사태 효과 때문에 1비트 오류난게 전체한테 영향을 미친다. -> error propagation 특성.

이게 안좋다고 생각할 수 있지만, 좋다고도 볼 수 있다.

지금 보는건 암호화가 아님.
보내는 사람이 인크립션을 쭉 진행후, 사이퍼텍스트 마지막 한블록이랑 플레인 텍스트 전체를 보냄.
![보안 9주차 이론-9](images/보안%209주차%20이론-9.png)

받는 사람도 플레인텍스트를 순방향으로 돌린다음에 마지막 사이퍼텍스트를 구하고, 위의 Cn과 같은지 확인.
만약 에러가 있는 플레인텍스트였다면 Cn이 서로 달라지겠다.
=> 중간에 오류가 발생되었는지 아닌지 확인 -> 무결성(integrity) 제공, authentication(인증) 제공

공격자가
parity나 CRC코드는 플레인텍스트를 알고 의도적으로 오류를 내고 그에 맞는 사이퍼텍스트블록도 의도적으로 바꿀 수 있는데,
CBC같은 경우는 key를 알아야지만, 플레인텍스트에 일부러 오류를 냈더라도 그에 맞는 의도적인 사이퍼텍스트블록을 만들 수 있음 -> 공격불가 -> 따라서 아 내가 아는 그사람(키를가지고있는사람)이 보낸거 맞구나 -> authentication 제공

그 마지막 싸이퍼블록 (Cn)을 MAC 또는 tag라고 부른다.

따라서 Message Autho Code 또는 Message Integrity Code 같은말. 둘다 무결성, 인증 제공

13)
나머지 3모델은
블록사이퍼를 이용해서 스트림 사이퍼를 흉내내는 모델.

스트림사이퍼를 다시 리뷰해보자.

one time pad -> 플레인텍스트 길이의 키가 있다면 xor 시켜주는거 만으로 완벽한암호.
하지만 그게 불가능하기때문에
자그마한 seed key로 알고리즘에 의해 긴 key를 생성해내는 것이 스트림싸이퍼.

복원할 때 같은 시드키가지고 같은 stream generation 돌리고, 그 키로 xor시키면 그대로 플레인텍스트나옴.

블록사이퍼는 반대순서로 역연산을 해야 디크립션인데,
스트림사이퍼는 순방향으로 인크립션해주면 디크립션된다.

14)
3. CFB(cipher Feedback) Mode

중간에 select, dicard는 편의상 무시

처음엔 이니셜 벡터로 플레인 텍스트와 xor,
그다음부턴 그 결과와 plain 텍스트를 xor.
쭉.
=> 스트림사이퍼 모드.

CBC모드와 비슷해보이지만, xor이 어디있냐가 포인트.
CBC는 인크립션과 디크립션이 반대이지만,
CFB는 디크립션할때도 그냥 인크립션 알고리즘 돌리면됨. 마치 스트림 사이퍼.

사이퍼텍스트 수신자도 이니셜벡터와 K를 넣고 정확히 같은 인크립션 과정을 반복하면 디크립션된다.

포인트는 네모친 부분이 같다는거. 역연산이 필요없다는거.
![보안 9주차 이론-10](images/보안%209주차%20이론-10.png)

블록사이퍼와 스트림사이퍼를 구분하려면, 디크립션을 보면됨!

하지만 이걸 완벽히 스트림사이퍼라고 보기 어려움.

seed키 만으로 키 스트림을 만들 수없음.
피드백을 주는 대상이 플레인텍스트에 의해서 생성되는 놈이기 때문. 따라서 플레인텍스트를 기다려야함
-> 인크립트의 아웃풋에서 피드백을 주자

15)
4. OFB(Output FeedBack) mode
nonce는 이니셜벡터(IV)라고 생각하면 됨.

키와 이니셜벡터만 있으면 플레인텍스트가 없어도 키를 쫙 뽑아낼 수 있다.

…

플레인텍스트가 바뀐다고해서 뒷부분에 영향을 미치지않아서 MAC용으로는 쓸 수없다.

CBC나 CFB는 플레인텍스트의 일부가 바뀌면 전체한테 영향을 미치기때문에 MAC용ㅇ로 사용가능.
그러나 주로 CBC모드를 더 많이사용.

16)
5. CTR(conter mode) 모드

피드백을 아예 없앤모드. 앞뒤 관계를 없앴다.
-> 따로 병렬처리가능
또 각각 관계가 없기때문에 랜덤액세스도 가능.

ECB랑 같은거아니냐? 카운터가 다 다른 값 1씩 증가.

디크립션도 스트림사이퍼이기 때문에 인크립션 디크립션 과정이 같다

공격자가 카운터를 안다면?
![보안 9주차 이론-11](images/보안%209주차%20이론-11.png)

카운터를 알아도, 플레인 싸이퍼 쌍을 알아도 저 중간에 빨간지점을 모르기때문에
쌍을 알아도 키를 모르면 다른 플레인-싸이퍼 쌍을 해독할 수 없다. 

17)
피드백 특징 비교
ECB모드는 제외

…

CBC랑 CFB 모드는

점선 박스가 키스트림 제네레이션에 해당하는 부분

18)
5가지 모드의 특성
블록 스트림 구별방법? 복호화때 encrypt를 쓰면 스트림, decrypt를 따로 쓰면 블록

프리프로세싱 : 미리 키를 뽑아낼 수있냐. 플레인텍스트를 피드백으로 기다려야하냐.

