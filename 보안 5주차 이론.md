# 보안 5주차 이론

**공지
8주차 저녁에 시험
큰 문제가 없으면 오프라인으로 출석시험으로 볼예정 -> 메일로 의견받을 예정

2장 복습.

…

3장 고전암호.

2)
얼마나 고전이냐.. 그리스 시대 얘기부터..
2가지계열
substitution 계열 (치환)
transposition 계열 (전치)

3)
정의

- plaintext 평문. 우리가 숨기고 싶은 메세지
- ciphertext 암호문. 숨겨진 메세지. 알아볼 수 없는 형태
- Enciphering/encryption - 암호화, 비화 평문을 암호문으로 바꿔서, 공격자가 암호문을 혹여라도 봤을때 내용을 알아볼수 없도록 하는거 (confidentiality, 기밀성)
- Deciphering/decryption - 복호화 암호문을 다시 평문으로 바꾸는 과정
- Cryptography - 암호학, 마치 방패 암호화하고 복호화하는것을 연구하는 학문
- Cryptographic system / cipher 암호학에서 연구하고 발견한 알고리즘들, 시스템
- Cryptanalysis, 마치 창과같다 공격자입장에서 암호학을 분석하는일.
- Cryptology 창과 방패를 다아우름

우리가 여기서 배우는것에 대하여)

암호호된 메시지가 날라가고 있으면 내용은 볼 수없지만, 뭔가 중요한 내용이 통신이 되고있다
-> traffic analysis 공격
-> 막으려면 tor같이 라우팅을 숨기는걸 쓰던지,
스테가노그래피같이 메시지를 숨겨서 보냄(traffic analysis 대상이 아님)

=> 그러나 우리는 여기서 traffic analysis 을 막는 방법을 다루진 않는다

4)
암호화하는 측과 복호화하는 측이 같은 키를 쓴다 -> 대칭암호(symmetric encrpytion)
암호화, 복호화 알고리즘은 누구나 다 알수 있음
여기서 key가 안전성에 미치는 유일한 요소.

5)
conventional encryption : 관용암호, 수천년부터 사람들이 관용적으로 쓰던 암호
	-> symmetric cipher, 대칭암호가 이렇다는 뜻
- 암호화 알고리즘 자체가 강력해야한다.
- 키의 안전성이 유지가 되어야한다. 센더와 리시버는 키를 안전한 채널을 통해 공유해야한다. 그 키를 잘 비밀로 유지해야한다.
- 

6)
공격자가 중간에 사이퍼텍스트를 가로채도 알지못해야하는 것이 핵심
키의 안정성이 가장 중요하다.

8)
클래식 암호의 2가지 게열

글자를 다른글자를 대체 -> substitution 플레인 텍스트가 다른 숫자로, 다른 문자로 치환하여 암호화

글자단위로 할 수도 있고, 비트시퀀스 단위로 할 수도 있고

9)
가장 기본적인 치환암호로 시작해보자
시져 사이퍼 (Caesar Cipher)

10)
이러한 암호를 shift cipher라고 부른다

알고리즘 스샷참고.

왜 하필이면 3이냐? 이건 그냥 시저 생각이잖아
-> 따라서 더하는 숫자를 일반적으로 표현한게 k로 표현하고, k가 키값이 된다.

이 방법이 안전한가? 당연히 안전하지 않다

11)
키값 k가 뭔지모른다
-> 0~25사이 밖에 없으니까 다해보자.
근데 0인경우는 플레인텍스트 그대로니까 실질적으로 1~25(25가지)

이거만 다해보면 쉽게 답을 얻을 수 있다.

질문.
이걸 어떻게 하면 더 안전하게 만들 수 있을까?
-> 더 여러가지 조합이 나오도록 한다
-> 문자별로 키값이 다르게 해준다!

12)
monoalphabetic cipher

permutation 싸이퍼

a가 변환될 경우 26가지 중선택
b가 25가지중 선택(이유 : 겹치게되면 복호화시 알아볼 방법이 없음)
…
=> a~z까지의 암호들을 총 26!의 가지수로 암호화가능

헷갈리면안되는것)
퍼뮤테이션이란 뜻이 위치를 바꾼다는 뜻인데
meet -> emte : 이렇게 위치를 바꾼다는 뜻이아님( 이건 전치암호)
지금 위치를 바꾼다는 용어의 뜻은 평문의 글자의 위치를 바꿔서 전치암호처럼 바꾸는게 아니라
알파벳들을 다른 알파벳으로 치환할건데, 그 알파벳들이 배열처럼 생겼다 해서 퍼뮤테이션이란 용어 사용

13)
key스페이스 공간이 굉장히크다. (키스페이스 :가능한 키의 개수)
-> 스페이스만 보면 현대암호보다도 10억배이상이나큰..
(DES는 예전에썼던 암호, 허나 지금도 옛날시스템에선 쓰는,
AES는 최근에 사용하는 암호)

근데 진짜 안전하냐? 아니다.
monoalphabetic이라는 특성때문에 깨진다.
같은 글자는 계속 같은 글자에 대응된다는 성질

14)
a부터 z까지 평범한 문장에서 어느정도 비율로 나오는지.

e같은경우는 평범한 문장이 있을때 8글자중 하나는 E
a, e, t 일 확률이 30퍼센트 정도됨
=> 이사실을 공격에 이용

15)
또 영어에는 두글자 이상이 모여서 다니는 특징이 있음 (ex: th, the)
digram, trigram
=> 이 사실도 공격에 활용

16)
공격해보자

P라는 글자가 가장많이쓰이고
Z가 그다음
…
위의 차트와 비교해봐서 가정하여 대응시켜보자
P-> e, Z -> t …

또 두글자, 세글자가 짝지어 많이나오는거 체크하면
ZW, ZWP, ZWSZ … 
-> zw가 th가 아니겠느냐..

연관지어 다른 글자들도 추측 …

=> 지금 얘기한거만해도 수치를 더해보면 약 40퍼센트.
26개중에 4개밖에 안됐는데.. (t h a e)
-> 벌써 절반가까이 복구를함..

평문상에서의 빈도가 암호문에서의 빈도에 그대로 들어나는게 문제.
자 이걸 어떻게 막을까?
같은글자가 여러 문자에 대응대도록

17)
카운터 measure
1. 한글자를 대응 시키는게 아니라 여러 글자를 대응 e->z가 아니라, er-> , ez-> 이런식으로
2. 한글자로 대응시키긴하는데, 문맥에 따라 글자의 대응 규칙을 바꾼다. -> 이런걸 polyalphabeitc : 플레인텍스트 1글자에대해 여러개를 대응시키겠다.

18)
첫번째 방법부터 보자
Playfiar 방법
잘 알려진 여러글자 대응시키는 방법

2글자씩할거고,
5x5의 테이블를 이용할것

wheatstone 이라는사람이 만들고, playfair이 열심히 홍보해서 playfair이름이 붙음

세계1,2차대전에서 실제 썼었던 방법

19)
예제

책 97페이지에 나오는 대응방법
1. balloon같이, 이 시스템은 같은 글자가 2글자가 나오는걸 좋아하지않는다 -> 의도적으로 다른글자를 집어넣어준다 -> balxloxon : 이거를 플레인 텍스트로. 사이에 넣은 글짜는 X처럼 잘 안쓰이는글자로 암호를 복호화한사람이 잘 알아먹어야함
2. 테이블에거 샅은행에 있는경우  -> 다음행 글자로 ar -> RM  *i와 j는 같은 같을 공유 -> i와 j가 똑같이 복원함 -> but 복호화해도 헷갈리지않을꺼니까 그냥 씀
3. 같은열에있는경우 -> 다음열글자로 mu -> CM
4. 둘다 아닌경우 hs -> bp hs가 두 꼭지점이 되도록 직사각형을 그림 그리고 그 직사각형에서 h다음 행의 글자, s다음행의 글자

복호화하는 경우는 역으로 하면 된다.

그러면 그 문제가 해결되었느냐.
in이라는 글자 -> GA
it -> KS
똑같이 i로 시작했는데 다른글자가됨
-> 똑같은 글자라도 그떄그때 다른 글자로 대응되도록 목표달성!

하지만 완벽하진 않음.

왜냐하면 in이라는 글자는 항상 GA으로 대응될것
-> 두글짜씩으로 분석했을때는 통계적인 특성이 살아있을것

20)
차트처럼
플레인텍스트의 분포를
random polyaphabtic(어떤 이상적인 방법이 있다고하면) 분포처럼 일직선으로 만드는게 목표

Playfiar방법을 썼더니 조금은 완만해짐

21)
두번째방법
한글자를 한글자로 대응시킬건데 그 규칙이 매번 바뀜
-> polyalphabeitc cipher

22)
그중에 대표적인데
vigenere cipher

가장 잘알려져있고, polyalphabeitc cipher중 가장 간단

23)
예
키 : 키워드를 정하고 그것을 반복한다.
keyword들 반복시킨거랑
플레인텍스트 글자수를 맞추고
시저사이퍼랑 동일하게 시프트 시킴

이렇게 되면 플레인텍스트상 똑같은 e지만 key에 어떤 글자를 만나느냐에 따라 싸이퍼텍스트가 달라진다.
-> 암호문만 가지고 특정 글자수를 세봤자, 아무의미 없다.

24)
이 역시 완벽하지 않다..

xKasiski attack : 카시스키라는 사람이 공격함(하지만 나중에 보니까 babage라는 사람이 먼저 공격했다고 알려짐)

공격을 어떻게하느냐
공격자가 원하는건 ciphertext밖에없음
이거만가지고 원래의 key와 plaintext를 복원시키는것

공격 2단계
1. 키워드의 길이 알아내기
2. 실제 플레인 텍스트 복원시키기

특정 글자가 반복되는일이 우연히 생길 수 있음
스샷에서 red. -> 싸이퍼텍스트에서 똑같이 나오게됨
하지만 이러한 확률은 거의 0에 가까움
이런 일이 있으면 같은 키와 같은 플레인텍스트가 만났다라는 징표,
상대적인 위치를 계산해서 키의 길이 구할 수 있음.

이렇게 나오지않아도,
키의 길이를 5라고 찍는다.
그걸 5글자씩해봐서 쉬프트해서 통계분포를 따져본다.
하지만 틀렸기때문에 uniform한 분포가나온다. (일직선)
그러다가 9라고 찍는순간, 실제 영어글자 분포와 비슷하게 나옴
-> 아 키의 길이 9구나 알 수있음.
스샷에서 빨간색글자끼리 모아서 따로 분석, 파랑색글자끼리모아서 따로분석, 초록색글자끼리모아서 분석하면 된다.

뭐가 문제일까.
-> 키를 반복해서 썼기때문에 문제가 된것

25)
vigenere autuokey system
키를 반복해서 쓰지말고,
처음에 deceptive키를 이용하는건 같은데
그때의 대응되는 플레인텍스트를 키의 일부로 사용하자.

복호화하는 사람은 최초 9글자의 키를 가지고있음
최초 9글자만큼 복원시키고, 그 복원시킨 글을 새로운 키로해서 다음 9글자복원 .. 이런식으로함

-> 키가 반복되지 않으니 좀더 안전해보지만, 역시 완전하지않음
영어를 썼기때문에 충분한 양의 싸이퍼텍스트가 주어지면 통계적으로 분석가능 할것

26)
그럼 영어가 문제다.
비트로 쪼개다

vernam cipher

텍스트를 비트로 바꾸고, 비트를 암호화
![보안 5주차 이론](images/보안%205주차%20이론.png)

시저 사이퍼와 논리는 같지만,
비트를 사용하기 때문에 플레인,싸이퍼,키 모두 0,1만 가능

어떻게?
![보안 5주차 이론-1](images/보안%205주차%20이론-1.png)

이거뭐야 => XOR
![보안 5주차 이론-2](images/보안%205주차%20이론-2.png)

mod 2의 성질때문에 k를 빼거나 더하거나 mod 2 하면 같은 값이 나오기때문에
암호화할때도 복호화할때도 xor 연산을 한다.

-> 역시 버지니어 사이퍼처럼
비트시퀀스를 반복사용하면 약점이 있다.

27)
반복하지말자
One-Time pad : 키를 한번만 쓰고 버린다. 하나의 메시지에만 이용.
새로운 메시지를 해독하려면 이전 키를가지고 해독한 같은길이의 이전메세지를 새로운 키로 이용해야함

-> 이는 깨지지않는(unbreakable)한 완벽한 암호이다.
슈퍼컴퓨터 있어도 못푼다.

![보안 5주차 이론-3](images/보안%205주차%20이론-3.png)

c가 1일때 k가1인지, p가 1인지 알 수 없음
-> 그냥 확률적으로 찍어야함. 컴퓨터도 풀지 x
28)
현실적인 문제는 존재함

백만비트 플레인텍스트를 안전하게 전송하고싶다
->백만비트의 랜덤키를 상대방에게 어떻게 전송할거야?
->그런 안전한채널있으면 거기서 플레인텍스트 보내면 되는거아니야?

=> 실용적이지않고,
low-bandwidth(글자가 짧고), 매우 안전이 필요한 경우에만 사용

그럼 어떻게할거냐 
-> vernam으로 방식으로 다시돌아가자
 stream cipher를 이용하여 얘의 기능을 시뮬레이션해서 쓴다, 가 현대의 상황

29)
전치암호.
중에 rail fence cipher
지금까지 배운거랑 좀 다른계열
지금까지는 글자를, 비트를 다른 걸로 대체하는거 였음

이건 글자의 위치를 바꾸는것

가로로 써져있는 텍스트를 세로로 쓴다.
여기선 depth를 key로 사용(몇줄로쓸거냐)
그거를 다시 가로텍스트로 전송.

복원하는 사람은 depth가 2라는걸알면
적당히 반으로 자른다음에
2줄로만든다음 읽는다.

이거는 원래 플레인텍스트의 글자들이 그대로 싸이퍼텍스트에 존재. -> 영어글자 분포는 그대로존재.
단지 섞여서 나타났을뿐.

30)부터는 다음시간.

*스샷못찍은구간 7, 21, 22

