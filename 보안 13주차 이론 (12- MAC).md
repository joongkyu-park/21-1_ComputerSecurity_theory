# 보안 13주차 이론 (12. MAC)

1)
MAC
Message Authentication Codes

2)
Contents

3)
Message Authentication Code

- MAC의 요구조건 - 통신상에 있어서 신원을 가장할 때 -> 송신자가 누구인지 확인 : Authentication - 중간에 메세지를 변조하거나, 없는 메세지를 만들어 보낸다거나, 순서나 시간을 변조한다던가 -> 변조확인 : Integrity

=> 이런 것을 막기 위해 MAC을 쓰겠다(Authentication과 Integrity 를 동시에 제공)

- MAC의 기능 - 입력이 메세지와 key 두 가지. 보통의 인크립션과 비슷하다. -> 결과물이 싸이퍼텍스트면 인크립션인거고, Authentication과 Integrity을 체크하기위한 고정된 길이의 어떤 코드값이 나온다 그러면 MAC인거고. MAC = keyed hash 이런 인증을 위한 부가적인 값, 플레인텍스트에 붙여서 보내는 값 -> 그것을 ‘authenticator’라고 한다. 정해진 길이의 값.

4)
그림으로 한번 보자

(a) 기본적인 Message authentication
여기서 C라는 것은 블록사이퍼의 CBC모드를 이용하는 MAC일 수도 있고, 해쉬기반 맥인 HMAC일 수도 있고.

confidentiality도 같이(즉 인크립션도) 할 수 있다.
K1:MAC을 위한 키
K2:인크립션을 위한 키
(b)
서명 먼저하고 통째로 인크립션

(c)
plaintext를 인크립션하고 거기에 서명

5)
그런데 굳이 방금전처럼 그렇게 하지 않는다.

MAC을 어떻게 만드느냐.
해쉬 기반으로 MAC을 만드는 방법 HMAC
 
MD5나 SHA같은 해시함수를 이용하여 MAC을 만드는 것이 이전에 DES 같은 블록암호보다 더 빨랐기때문에 해시함수기반 MAC을 자주 사용했다.

TLS처럼 TCP층을 보호하는것이아니라, IP층을 보호하는 IP security라는 걸로 HMAC이 사용되었다.

NIST 표준이기도하고

6)
동작과정.
HMAC이긴한데 어쨌든 MAC이다.
입력? 인증하고싶은 메세지와 key. (보내는사람 받는사람 같은 키)

입력으로 받은 키를 약간의 조작 후 사용

정한 블록의 크기가 b bits라고 하면,
메세지는 b비트의 배수의 블락 수를 갖고,
K는 b비트가 되기 위해 왼쪽을 0으로 패딩값을 K+가 되어서,
ipad(=inputpad) : 16진수로 0x36, 즉 1바이트가 내가 원하는 비트수가 되도록 계속 반복해서 만듬. -> b bits가 되어야하니까 b/8 바이트만큼 만들면된다.
이 ipad와 K+를 Xor시켜서 Si를 만듬.
메세지 맨앞에 붙이고, 해시함수 돌림. 이 때  n 비트짜리 이니셜벡터가 들어간다.
해쉬의 출력값으로 정해진 비트인 n비트의 아웃풋을 낸다.

이 출력값과,
K+와 opad(이번엔 0x5C를 반복한거)를 xor한걸 붙여서 다시 해시함수를 돌려서
최종 HMAC을 만든다.

ipad와 opad 같은 값은 정해져있는값. 누구나 가지고 있는값.

K+(사실은 K), M이 입력으로 들어가고
출력으로 HMAC(K, M)이 나온것

7)
블록사이퍼가지고 MAC만들기
CBC-MAC

DAA라는 알고리즘을 가지고 CMAC을 만드는데,
CBC모드와 같다. 차이점은 이니셜벡터와 xor하는 부분이 없다.
DEA(Data Encryption Algorithm)와 짝지어서 만들어진거라 블록사이퍼를 굳이 DES로 인크립션 하였다.

정확히 CBC 모드다. 이니셜벡터들어가는거 빼고.

결과로 나온걸 DAC이라고 말한다.(MAC 대신에)

8)
그러나 이렇게 했을 때 문제가 있다.
공격이 된다.
 K와 X를 넣어서 만든 DAC(K, X)가 있을 때,

DAC(X || X⊕T) = T가 된다.
X : 첫번째 플레인 텍스트 블록
X⊕T : 그 X에 태그로온 T를 XOR 시킨다.

공격자는 한블록짜리 플레인텍스트에 T가 붙은 X || T만가지고
MAC(T)를 만들어 낼 수 있는 상황.

그것을 보완한게 CMAC
마지막 블록을 계산할 때 하나의 추가적인 키를 더 넣어서 XOR 시킨다

9)
그림으로 보자.

DAC같은 공격이 적용되지 않는다.

(a)는 마지막 블록이 자투리 없이 블록크기와 맞아떨어질때(이 때는 K1이라는 키 이용)
(b)는 그렇지 않을때, 나머지 부분에 10…0인 패딩값을 집어넣는다.(이 때는 K2라는 키 이용)

K1, K2는 어디서 나는거냐.
원래는 K, K1, K2를 다 따로줬지만 키가 너무 길어지므로
최근에 쓰는 CMAC에서는 K로 부터 K1, K2 유도 가능하게 한다.

플레인 텍스트도 b bit, 싸이퍼텍스트도 b bit.
![보안 13주차 이론 (12- MAC)](images/보안%2013주차%20이론%20(12-%20MAC).png)

L : 0으로만 이루어져있는 b비트의 플레인텍스트를 인크립션한 싸이퍼텍스트 같은 것
그 결과를 GF(2^b)의 내의 원소로 본다. 하나의 갈루아필드 원소, 하나의 다항식으로 보겠다
거기다 x를 곱한다.(왼쪽으로 한비트 시프트) -> K1
거기다 x^2을 곱한다 -> K2

10)
인크립션, 어쎈틱케이션, 인테그리티를 다 같이 하는 상황
Authenticated Encryption(AE)

- 인크립션한다음에 해시를 하겠다 -> 말이 안된다. 키없이 해시만 하는건.. 안전성 보장안되니까
- auth. 먼저하고 encryption 할것이냐,
- encryption 먼저하고 auth. 할것이냐
- 아님 그냥 따로 할것이냐

각각 마다 안전성상의 문제가 있다

11)
따라서 그런 자명한 방식보다 조금더 복잡한 방법이용
CCM, GCM 두가지

CCM
Counter 모드로 인크립션 후 CBC모드를 이용해 MAC
무선랜 표준인 IEEE 802.11 WIFI 에 사용됨.
CCM을 개발한 동기가 무선랜의 안전성을 보장하고자했던게 크다

이름은 CBC-MAC을 쓰지 않고 사실 그것을 보완한 CMAC을 사용한다.

여기선 encryption과 MAC을 따로 해서 붙인다.

알고리즘의 주요요소들
- AES 블록사이퍼를 쓰도록 되어있음. 꼭 AES를 써야하는건아님, 그냥 권고
- 암호화는 카운터모드
- Auth.는 CMAC사용

  인크립션과 MAC에 동일한 키 K 사용

12)
좀 더 구체적으로 보자
CCM. 인크립션과 Message Authentication을 동시에.

여기선 2가지를 구분한다.
- 인증도하고 암호화도할 데이터 ex) 통신할 때 일반적인 데이터. paylaod
- 암호화는 필요없지만 인증을 해야하는 데이터 -> associated data ex) 통신프로토콜의 헤더 같은거. ip address를 조작하면 안되지만, 암호화 해버리면 라우팅 자체가 안되잖아. 
- replay attack(재사용)을 막기위해 매번 보낼때마다 바뀌는 값을 만들어 준다. -> nonce N 사용 ex) 100원을 송금함, 이라는 내용을 보낼때 지금 보내는거랑 한시간뒤에 보내는거랑 비트가 다를 것이다. nonce 때문에 그런데 같은 내용이 같은 비트로 전송된다고하면 이건 누가 복제해서 보낸 것이기 때문에 방어가능

이런 데이터와 + key 가 입력으로 필요

13)
과정 보자

auth. 결과를 인크립션에 넣거나, 그 반대도 아님.
각각 독립적으로 플레인텍스트가 들어가고, 나중에 합치는것

(a) Authetication
-> CMAC사용

입력 3가지. 플레인텍스트. 인증만할 데이터. nonce
이런것들을 합쳐서 전체블록. 그게 authentication의 대상
이거와 K를 CMAC에 돌려서 나온걸 Tag라고 부른다.
(b) Encryption
associated data는 인크립션 대상이 아니니까, 플레인 텍스트만 넣고, 카운터모드를 K를 이용하여 돌린다.
카운터 1~ 카운터 n번이용을 하는데,
카운터0번과 키를 이용해 인크립션을 돌린 결과에, 위의 태그를 xor해서 결과로 MAC을 주는 것
그래서 카운터 0와 카운터1~n번과 피드백을 주는건아니지만 카운터라는 연관관계가 있다.
따라서 독립적으로 한것처럼 보이지만, encryption 부분과 authentication 부분이 카운터로 연결된다고 볼 수 있다.
MSB라는 것은, 특별한 과정이 아니면 CMAC을 나오는 거쳐서 나온결과가 블록사이퍼의 한블록의 크기지만, 그거와 다른 길이로 나오게 한다면
ex) 블록사이퍼는 128비트 쓰는데 나는 80비트 태그만 쓸거다하면,
Ctr0를 인크립션 한 애들 Most Significant, 즉 최상위 80비트만 떼어서 쓴다는 뜻.
그럼 결과로 나오는 것도 80비트가 되겠지.

14)
CCM이 성능상에 문제가 있다. 병렬화가 안됨
카운터모드는 병렬화가 되는데,
CBC모드는 그게 안됨.
근데 CBC가 MAC으로
GCM모드는 2가지 함수를 쓴다
- 카운터모드를 약간 바꾼 GCTR모드를 이용. 연산을 한번씩 할때마다 하나 증가되는 카운터. 뭔가 직접적인 연관이 있는건 아닌데 간접적으로 연관이 있는.. 그런느낌
- GHASH 함수. 맥용으로 쓰는거. keyed hash function(=MAC)

15)
GHASH : 맥 생성부분

H : 0이 128비트 있는걸 K로 인크립션한거. K가 정해지면 H값은 정해지겠다.
 플레인텍스틀 128비트 씩 나누어서 X1 ~ Xm
*H = H와 각 X블록을 GF(2^128)의 원소로 본다. 그 다항식 두개를 곱한다 -> Y
물론 irreducible polynomial이 있고 그걸로 mod 연산해야지
Y1을 만들었으면 X2에 피드백을주고 XOR시키고, 같은 방법 반복.

CBC모드와 유사하다.
K를 넣고 인크립션하는 부분을, K에 의해서 생성된 H라는 녀석과 곱하는걸로 바뀐것 뿐

이런 피드백이 생기니까 앞에꺼가 계산이되어야 뒤에꺼가 계산이되고,
X1에 문제가 생기면 쭉 영향을 미치면서 마지막 Ym에 영향을 미치게되는, 결과적으로 태그에 영향을 미치게 되는 상황처럼 보인다.

그러나 앞에서 GCM의 장점이 병렬화라고 했다.
보자.
앞의 두단계만 보자면
![보안 13주차 이론 (12- MAC)-1](images/보안%2013주차%20이론%20(12-%20MAC)-1.png)

다음번째를 곱하기 이기때문에, 이렇게 풀어서 쓸 수 있다.
인크립션은 이렇게 풀어서 쓸 수가 없음
따라서, 마지막 블록인 MAC을
![보안 13주차 이론 (12- MAC)-2](images/보안%2013주차%20이론%20(12-%20MAC)-2.png)

이렇게 풀어서 쓸 수있음
앞에가 영향을 받으면 뒤쪽도 다 영향을 받는 MAC의 기능은 여전하지만,
병렬화가 가능해졌다

GCTR
inc는 counter increment 시키는것

마지막 카운터는 인크립션 한다음에 MSB(최상의 일부만 떼어내는)한다. (자투리 부분이 있을 수도 있으니까)

오른쪽은 실제 갈루아-카운터 전체모습
IV를 인코드하는건 그냥 다른 값으로 바꾸는것. 자세히는 설명안함.
그 나온값을 카운터 값으로 넣고 GCTR 실행.
그 결과로 나온 싸이퍼텍스트와, 인증만을 원하는 데이터, 0패딩, Associated data길이, 싸이퍼텍스트의 길이값 등을 묶은다음에 GHASH를 돌린다.
그 결과를 바로 쓰는게 아니라 GCTR를 돌린담에 MSB로 짤라서 그걸 MAC으로 쓴다

16)
여기까지보면,
갈루아필드 같은게 되게 많이쓰인다는걸 알수있다.
AES설계과정에서도 쓰이고, CMAC에서 K로부터 K1, K2를 유도하는데 쓰였고
갈루아카운터모드 같은데에서도 쓰이고

따라서 이거를 빠르게 돌리서 이런 연산을 하드웨어로 구현하여 제공하기도 한다.
인텔의 최근의 cpu들은 이러한 인스트럭션을 제공해준다. carry없이 곱셈을 64비트의 두 입력을 곱셈하는건데, 쉽게말하면 바이너리필드연산을 제공한다는 뜻.

PCLMULQDQ같은 인스트럭션(어셈블리어)는 바이너리 갈루아필드 연산을 제공하는데,
최근에는 인크립션에서는 문제가 발견되어서 GF(p)같은 소수의 갈루아필드를 사용해서 인크립션엔 사용이 잘안되고, GCM 모드같은 경우에서의 계산에서는 사용이 되겠다.

17)
우리나라에서 공공기관에 납품하는 암호에 대해서는 검증을 받아야하고,
그걸 검증하는걸 KCMVP 라고 했었다. (검증 대상 암호알고리즘)

18)
전체적인 로드맵.

아래쪽에 Public Key Certificate, Block chain이랑
Digital signature쪽에 ElGamal, DSA, ECDSA 만 안했다.

19)
요약

