# 보안 6주차 보강 (6단원)

AES 암호를 다룬다.
AES는 이전에 nist 표준이었던 des가 취약점이 발견되면서(키의 길이가 짧아서. 구조적인문제는 x)
그 이후에 새로 표준화가 된 암호

2)
6장의 구성

3)
왜 블록사이퍼에 대해 finite field를 이용할 것인가.

- AES의 각 라운드를 구성하는 연산들 서브스티투션(3가지) 트랜스포지션(1가지) 여러개의 라운드로 구성 간략한 비트연산. xor같은

이 연산들을 이용해서 기대하는 것은,
어떤 인풋으로 들어온 플레인텍스트와 출력으로 나갈사이퍼텍스트가 최대한 연관관계가 없어보이도록 하는것. -> 암호화에서하는 일

라운드를 구성하는 각 함수들이 비트들을 랜더마이즈 해주면 좋겠다.
페이스텔 사이퍼에서는 나름의 방법이 있었지만,
최근의 설계암호들은 바이너리필드 연산을 가지고 bit randomizion effect를 구현하는 경우가 많다.(aes를 포함해서)
그런데 이 bit randomizion이 뭐냐면,
필드의 곱셈이나 필드상의 인버젼 연산들이 이런 bit randomizion 연산을 하게된다.
필드 : 사칙연산이 있는데, 덧셈뺼쎔은 같은 연산이었음. 바이너리 필드에서.
덧셈은 근데 랜더마이제이션 효과가 별로없음.
mod 2에 의한 덧셈은, 같은거 두번더하면 상쇄되버림(Xor) ->연산을 계속 반복한다고해서 복잡도가 올라가지않음.

따라서 곱셈,나눗셈이나 inversion 이용하면
비교적 적은 복잡도의 연산으로 비트가 이리저리 섞이는 효과를 볼 수 있다.
그래서 암호설계하는데 finite field를 많이 사용한다

4)
finite field를 좀 편하게, 효율적으로 구현하려면
우리가 다루고자하는 data 포맷에 정확히 맞는 필드를 사용하면 좋겠다.
만약 n-bit의 워드를 다루고싶다면,
![보안 6주차 보강 (6단원)](images/보안%206주차%20보강%20(6단원).png)

0부터 2^n -1까지 2^n개의 데이터조합이 있을 수 있는데,
이걸 자연스럽게 다루려면 이걸 정수로보고 2^n을 모듈러 연산하면
모든숫자들이 범위안에, nbit안으로 들어와서 연산을 반복할 수 있다.

하지만 2^n을 모듈러하게되는 연산은 필드를 구성할 수 없다.
저번시간의 GF(8)과 같은.

따라서 2의 거듭제곱수를 정수로 다룰수는 없고, 바이너리 필드 형태로 바꿔서
모든 원소를 숫자가 아닌 계수가 2진수인 다항식으로 표현하게 되면
위의 0~2^n -1까지 이진수들과 잘 맞아떨어지면서
n bit의 비트시퀀스를 잘 표현할 수 있게 된다.
그래서 바이너리 필드를 쓴다.

5)
AES의 경우에는
GF(2^8)인 파이나이트 필드를 쓰로 있다.

따라서 8비트, 즉 바이트 단위의 연산을 많이 쓴다.

덧셈(=뺄셈), 곱셈, 나눗셈들의 연산들을 GF(2^8)에서 실행하게 되는데,
8차의 irreducible 다항식이 필요하게 되는데,
![보안 6주차 보강 (6단원)-1](images/보안%206주차%20보강%20(6단원)-1.png)

이것을 표준으로 정했다.
(+ 8차의 프라임다항식은 많고, 또 그걸써도 문제가되거나 안전성의 문제가 있는건 아니지만
그냥 모든사람이 이걸로 약속해서 쓰는것.
만약에 이 다항식으로 암호화했는데 다른 다항식으로 복호화하면 안풀리니까)

(+
![보안 6주차 보강 (6단원)-2](images/보안%206주차%20보강%20(6단원)-2.png)

mod 2 동네의 특성을 이용하면(덧셈=뺄셈, …)
x^2 + 1 같은 다항식은 원래 인수분해가 안되지만 다음과 같이 인수분해가 된다. (mod 2를 적용하면.)

그러나 이러한 특성를 감안해도 irreducible 다항식은 인수분해되지 않는다.)

6)
AES
표준이다. by NIST in 2001
DES의 키의 길이가 너무 짧아서 생기는 안전성 문제 때문에 공모를 해서 뽑았다.

nist 사이트에서 표준을 누구나 다운받을 수 있다.

표준화 과정 가운데, 개방형 설계를 채택했다.
표준화를 시킬 때 전세계의 암호연구자를 대상으로
des의 후보를 뽑을테니 제출하라고 해서 공모함.
최종적으로 하나 남은게 Rijndael(라인달)이라고하는 암호. 벨기에사람이 만듬.
라인달 알고리즘이 aes의 후보였고, 다른 경쟁자들을 이기고 aes 표준이 되었다.

근데 미국의 암호표준인데, 다른 나라사람들이 제출한걸 쓴다는게 좀 이상한데..?
-> 여러사람이 검증해주면 더 안전해지지 않겠냐, 라는 철학으로 함

+) DES같은경우는 IBM에서 만든 루시퍼라는 암호에 기초하고있는데,
전세계를 대상으로 공모한건아니었고 NSA가 내부적인 검증과정을 거쳐서 DES를 지정했다.
IBM의 암호를 만드는 개발팀을 이끄는 사람이 Feistel이었다.
그래서 그런 계열들의 암호를 페이스텔 암호로 부르게되었다.

7)
aes의 일반적인 구조

state라는 자료구조 사용
4x4의 2차원 행렬, 바이트들로 구성.
다 더하면 16바이트. -> 16바이트 단위의 자료구조

des같은경우에는 왼쪽 32비트, 오른쪽 32비트해서 64비트를 쭉 라운드하는 구조로 되어있었는데
aes에서는 128비트 단위로 하겠다.

플레인텍스트도, 중간결과들도, 사이퍼텍스트들도 128비트(16바이트)의 스테이트 구조를 쓰겠다.

aes는 요구되는 안전성 수준 별로 3가지 키를 쓸 수 있다
128, 192, 256비트. -> 더 길수록 당연히 더 안전
이에 맞춰서 라운드수도 10, 12, 14 -> 더 많을수록 안전
그러나 키가 길거나 라운드가 많을수록 연산속도가 떨어진다.

aes는 SPN(substitution-permutation** **network이라는 구조를 쓰고 있다.
substitution연산과 permutation연산을 반복해서 하는 네트워크로된 구조다라는 뜻

알고리즘 이름은 라인달
표준이름은 AES
라인달처럼 설계한 암호를 SPN이라고 부른다는뜻. 분류

SPN구조의 특징은,
페이스텔처럼 반씩 또는 적당한 부분씩 나눠서 순방향으로 진행하고
복호화할때도 암호화 과정을 똑같이 반복하는게 아니고,

복호화할때는 암호화의 과정을 거꾸로 올라간다.
모든 연산들이 각각의 역연산이 존재하는 구조.

round들이 역연산이 가능한 4가지 트랜스폼으로 구성된다.
permutation : shift row
substitution : subBytes / mixcolumns / addroundkey

8)
방금 본 파라미터
워드는 바이트를 4개씩 묶은것.

키의 길이는 3가지 버전이 있지만
플레인텍스트, 사이퍼텍스트는 항상 128비트로 고정. (사람들이 많이 헷갈린다.)

키의 길이에 따라 라운드수가 변한다.
라운드가 늘어날수록 라운드 별로 쓰여아하는 서브키들도 많아진다.
서브키 길이 자체는 128비트로 똑같지만, 갯수가 많아짐. (expanded key size)

aes의 서브키가 이용되는 구조는
맨첫번째 라운드 들어가기전에 한번 이용되고
각 라운드별로 서브키가 1개씩 이용됨.
라운드가 10개다 -> 서브키가 11개가 필요
라운드가 14개다 -> 서브키가 15개가 필요.

서브키 1개가 128비트(16바이트)니까
11개를 쓰면 176비트가 필요한거고.. 그런뜻

9)
AES 인크립션 과정의 전체적인 그림

처음에 플레인텍스트는 128비트로 고정
이거를 4x4의 2차원 배열형태로 표현하기로했다 (State)

바꾸는 과정은 4개씩 끊어서 워드들을 만든다음에 열로 배열함
![보안 6주차 보강 (6단원)-3](images/보안%206주차%20보강%20(6단원)-3.png)

이런상태로 initial transformation이라는 단계를 거친다.
별거아니다.
라운드가 10인, 키의길이가 128비트일때를 가정.
128비트의 키를 받아서 똑같이 state로 만든다.
그런 다음에 data state와 key state를 xor시키는게 이니셜 트랜스폼.

그 xor된 결과를 가지고 라운드를 돌린다. 10번

<앞으로는 가장 간단한구조인 n=10인 라운드가 10번인걸 기준으로 설명할것.
라운드 12, 14도 구조는 거의 똑같다>

처음에 쓴 키말고,
각 라운드에 필요한 라운드키(서브키)들이 있을텐데,
그 서브키를 만드는 과정이 	Key expansion(또는 key scheduling)이라고 부르는 과정이다.
이 챕터의 거의 마지막 부분에서 설명할 것.

전체적인 구조는
입력으로 받은 스테이트가 각 라운드를 거치면서 업데이트, 업데이트 될꺼고 (n번)
각각의 라운드 별로 서브키를 쓰게 된다.
서브키들도 각각 state형태로 구성되어있다.

마지막에 final state가 나오면,
![보안 6주차 보강 (6단원)-4](images/보안%206주차%20보강%20(6단원)-4.png)

열 순서다대로 다시 싸이퍼텍스트로 만들면 된다.

10)
모든 중간과정은 state라는 자료구조를 이용하게 된다.
![보안 6주차 보강 (6단원)-5](images/보안%206주차%20보강%20(6단원)-5.png)

바이트의 배열순서는 위와 같다

11)
지금까지는 개괄적인 구조.
조금더 구체적으로 보자

결국, aes내부에서하는일은 전체적인 데이터블록을 하나의 4x4바이트 배열로 보고
각 라운드별로 substituion과 permutation으로 업데이트를 하는것

근데 페이스텔과의 차이는,
페이스텔은 반쪽은 그대로가져오고, 반쪽만 업데이트하는 식으로 했었음.
그렇게 했던 이유는 순방향으로 다시 진행했을때 복호화 하기위해서.

지금은 그런 구조가 아니라 SPN구조이기때문에
입력으로 들어온게 전체가 업데이트 다된다.

업데이트를 하는 과정에서 키가 필요하다.
인풋으로 주어지는 키가, 32비트 워드가 4개가 모이게되면 128비트의 하나의 스테이트가가 될텐데
이게 11개가 필요할건데(라운드가 10이라면)
워드 기준으로보면 4*11개의 워드, 즉 44개의 워드가 필요하게 된다.
w[0] ~ w[43]으로 표기함

128비트 입력과, 키를 확장한 44개의 워드, 또는 11개의 128비트 서브키를 이용해서
10개의 라운드를 돌릴건데
라운드를 구성하는 함수가 4가지로 구성.
-substitue byte(sub byte 또는 byte sub)
바이트 단위로 치환하는것. 업데이트해주는 테이블을 S-box라고 부를것
-shiftRow
행  내에서 쉬프트, 즉 로테이트 시킨다
-Mixcolumns
컬럼내부를 섞겠다라는 뜻. 여기서 GF(2^8)의 연산을 사용
-AddRoundKey
라운드키를 에디션하는건데, 단순히 xor임

처음에 이니셜트랜스폼으로 addroundkey 연산이 한번 있다.
또 맨마지막 라운드의 맨마지막연산이 addroundkey 이므로 이거로시작해서 이거로 끝나게 된다.

싸이퍼 전체의 내부구조를 뜯어보면
addroundkey(즉 xor연산)과 위의 이리저리 섞어주는 3가지 연산들을 반복한 과정을 되어있다.

각 stage는 역연산이 가능한 구조로 되어있다.

디크립션 알고리즘은 인크립션알고리즘과 똑같지않다. 역방향

암호화든 복호화든 128비트의 state라는 자료구조를 이용할것.

10개라운드를 기준으로했을때, 9라운드는 똑같고 마지막 라운드는 약간 다르게 생겼다.

12)
이런구조다.

16바이트의 플레인텍스트, 16바이트의 키가 입력
키는 expand를 거쳐서 11개의 워드 또는 44개의 바이트가 되고
w[0,3] = 0번째 키, … w[40,43] = 10번째 키 로 생성.

최초 add round key에서 k0 이용

각 라운드는 128비트의 서브키를 입력으로 받아서 128비트의 중간결과 state를 아웃풋으로 낸다.
라운드는 4가지 함수로 되어있다.

마지막 라운드는 믹스컬럼즈 연산이 없다.
왜그러냐.
이건 구현상의 편의성 때문에. (안전성을 해치치않는 범위라서)

13)
4개의 transform 연산들을 살펴보자

1. SubBytes
바이트 단위로 치환

각 바이트를 다른 바이트로 대체시켜주는 규칙이 있다. 그게 s-box
퍼뮤테이션 사이퍼같은데서 보면,
a->[ ], b-> [ ], … , z->[ ]로 바껴라 하는거같이 정해둔것. 26가지

여기선 00000000부터 11111111까지 256가지를 정해둔것

퍼뮤테이션 싸이퍼는 키에 따라서 a가 뭘로바뀌고 b가 뭘로바뀌고 하는 규칙이 달라졌다. 26!의 경우의수

여기선 그냥 정해져있음. 모든 s-box사용자들이 같은 규칙씀.
이건 key의 일부가아니라 정해진 방법임.
8비트 입력이 들어가서 8비트 출력이 나오면됨.
역연산이 가능하려면 8비트와 8비트의 대응이 1:1 대응이어야겠다.
![보안 6주차 보강 (6단원)-6](images/보안%206주차%20보강%20(6단원)-6.png)

 0000/0000 
왼쪽 4비트와 오른쪽 4비트를 나눠서
![보안 6주차 보강 (6단원)-7](images/보안%206주차%20보강%20(6단원)-7.png)

각각 세로와 가로에서 쓰면 256가지의 칸이 생기겠다.
그 칸에 하나하나 채워져있는게 출력으로 나올 바이트값이다.

state의 바이트 값을 읽어서 s-box에서 찾아서 출력으로 나와야할 바이트값이 뭔지를 찾아서 덮어써주겠다.
이걸 바이트단위로 16번 반복하겠다.

14)
이게 s-box
xd의 인덱스가 16가지, y의 인덱스가 16가지 있다. 0번부터 F까지.
편의상 16진수 2개로 적혀있고, 다 다름. 같은거 하나 없음.
256!의 가능성 중에 한가지 경우의 수로 고정시켜놓은것

ex) 00000000 (00) -> 01100011 (63)

역연산은?
15)
inverse s-box
앞의 테이블을 입력과 출력의 배치를 바꿔놓은것.

ex) 63 -> 00

16)
4x4테이블의 각 바이트들을 s-box를 거쳐서 다시 4x4테이블을 만든다.

s-box의 테이블 가능성이 256!가지인데, 그중에 하나를 정한기준은 뭐냐
입력으로 들어온 8비트를 GF(2^8 )의 필드상에 다항식 1개로 본다.
ex) 0000000 = 0*x^8 + 0*x^7 +.. 으로 보겠다.
그거의 역원을 구함 (곱셈에대한)
256개중에 255개는 역원이 있는데, 0에 대한 역원은 없는데, 편의상 0의역원은 0이라고 정의.
그거를 비트 단위로
![보안 6주차 보강 (6단원)-8](images/보안%206주차%20보강%20(6단원)-8.png)

이 위치에 넣는다. b0가 최하위비트.
이걸 미리 정해진 행렬에의해서 행렬연산을 시킨다.
그니까 256!가지의 가능성이 이 행렬이나 뒤의 열벡터를 바꾸면 달라질 수 있는데,
이걸 누구나 똑같은걸 사용하도록 정해놓았다.
그래서 어떤 사람이 수행해도 똑같은 입력이면 똑같은 출력이 나온다.

행렬연산후 
![보안 6주차 보강 (6단원)-9](images/보안%206주차%20보강%20(6단원)-9.png)

이거를 더한다. 이 때 더하기는 + mod 2 이다. (즉 GF(2)상의 연산). 다시말하면 xor

이 결과를 다시 맨위를 최하위비트로 해서 2진수로 만들면 결과가되는것.

그러면, 항상 미리 해놓으면 되지, 뭐하러 온라인으로 실시간으로 해야하는 상황이 있을 수 있는가.
메모리와 계산의 트레이드오프인데,
테이블을 만들어 놓으려면 1바이트 x 256개의 메모리가 필요할텐데,
그다지 크지 않으므로 대부분은 이 테이블을 가지고 있지만
이 메모리를 쓰기 어려운 자원이 한정된 상황이라면 이렇게 계산을 풀어서 하는게 유일한 방법일 수 있다.

역연산은 어떻게 된거냐.
![보안 6주차 보강 (6단원)-10](images/보안%206주차%20보강%20(6단원)-10.png)

이 행렬을 A라고 하고,

입력으로 넣은 걸 X,
그거의 역원을 X^-1 = Z,
아웃픗을 Y라고하면
![보안 6주차 보강 (6단원)-11](images/보안%206주차%20보강%20(6단원)-11.png)

이 식인데,

![보안 6주차 보강 (6단원)-12](images/보안%206주차%20보강%20(6단원)-12.png)

이렇게 해주면 된다.
![보안 6주차 보강 (6단원)-13](images/보안%206주차%20보강%20(6단원)-13.png)

나온 Z를 역원을 구하면 X가 된다.
![보안 6주차 보강 (6단원)-14](images/보안%206주차%20보강%20(6단원)-14.png)

물론 이것도 다 정해져있으니까 미리해둘 수 있다.

이걸 미리 만들어 놓은게 invers s-box

17)
왜 이렇게하는가.
s-box는 여태까지 알려저있던 암호학적인 공격에 대해 안전성을 가지도록 설계됨
인풋과 아웃풋 간의 상관관계가 거의 없게하길원했는데,
이렇게 하는 좋은방법이 linear가 아닌 수학적인 함수를 사용하는건데,
이게 대표적인게 곱셈이나 곱셈에 대한 역원같은거.  

리니어 하지 않는 mathematical function이라는게 무슨말이냐
약간 복잡하지만 중요해서 자세히 설명하겠다.
입력 128비트가 있다.
이걸 128비트 출력을 얻어낼것.
그러나 지금은 편의상 8비트로 설명. 
입력 8비트와 출력 8비트의 관계가 잘 안보이도록 하고 싶은데,
리니어 함수를 쓴다는 것은,
각 비트를,
입력 p : x0, … ,x7
▼ 함수 F
출력 c : y0, … ,y7 로 표현하면

공격자가 하고싶은 것은 우연히도 x0~x7값과 y0~y7값의 몇개의쌍을 알았다.
함수 F에 어떤 키가 개입되서, 키가 어떤게 오느냐에 따라서 F의 동작이 바뀌도록 만들건데,
그 관계를 이용해서 어떤 키가 사용되었느냐를 알고 싶은것.

가정은 똑같은 키를 사용해서 암호화시켰다고 생각.
![보안 6주차 보강 (6단원)-15](images/보안%206주차%20보강%20(6단원)-15.png)

p와 c간의 관계를 나타낸 식이 결국 암호화하는 과정인데,
그 과정에서 키를 모르는 상태로 p와 c만 가지고 키를 알아낼수 있겠냐, 가 문제

이걸 선형함수로 구현하면,
선형연산이라는건 덧셈,뺄셈같은 연산. 곱셈같은건 차수를 증가시키니까 안됨
예를들어
![보안 6주차 보강 (6단원)-16](images/보안%206주차%20보강%20(6단원)-16.png)

![보안 6주차 보강 (6단원)-17](images/보안%206주차%20보강%20(6단원)-17.png)

이렇게 있을 때,

x8개와 y8개의 연립방정식을 풀면 k의 값을 다 알 수 있다

그런데 미지수에 해당하는 값들이 1차가아닌 그 이상으로 표현되면
![보안 6주차 보강 (6단원)-18](images/보안%206주차%20보강%20(6단원)-18.png)

단지 8개의 인풋 아웃풋 순서쌍만으로 답이 안나오는 경우가 많다.

따라서 리니어하지 않은 함수로 구성해야한다.

multiplicative inverse같은 경우는 차수가 높아져서 선형함수가 아니다.
![보안 6주차 보강 (6단원)-19](images/보안%206주차%20보강%20(6단원)-19.png)

입력 7차 다항식, 출력 7차 다항식의 계수의 관계가
뭐를 xor시키면 뭐가 나오고 이렇게 간단하지 않는다는 뜻

이렇게 선형적이지 않게 하는 방법이 여러개 있을 수 있는데
그중에 비교적 쉽게 계산할수있으면서 not linear한 성질을 제공할 수 있는게 multiplicative inverse 이다.

18)
4가지 트랜스폼 중에 2,3번째

2. shift rows
단순히 위치를 옮기는것

이번엔 state를 행으로 보자
맨위의 행은 그대로 아웃픗으로
그다음행은 한바이트씩 왼쪽으로
세번째행은 2칸씩
마지막은 왼쪽으로 3칸(=오른쪽으로1칸) 옮긴다.

행 안에서만 움직이고 다른 행끼리 영향x

디크립션할때는 이동하는 방향만 반대로 해주면 되겠지

3. mix columns
열별로, 열내에서 연산

마찬가지로 열안에서만 움직이고 다른열에 영향 x

state의 각 바이트들을 GF(2^8)의 다항식으로 생각할 것이다.
ex) 2 = 10(2) = x , 3 = 11(2) = x+1
열들을 그림상의 행렬과 곱한다.

예시
![보안 6주차 보강 (6단원)-20](images/보안%206주차%20보강%20(6단원)-20.png)

이렇게 곱하면, 
2*a + 3*b .. 이게아니라
![보안 6주차 보강 (6단원)-21](images/보안%206주차%20보강%20(6단원)-21.png)

이렇게 되는것. (xor인이유는, 더하기나 빼기나 xor니까)

원래의 값을 다른걸로 대체시키니까
이것도 일종의 substitution 방식이다.

이걸 열별로 똑같은 행렬에 대해서 하겠다, 이게 믹스컬럼즈

이것에 대한 역연산은?
![보안 6주차 보강 (6단원)-22](images/보안%206주차%20보강%20(6단원)-22.png)

이 행렬의 역행렬을 결과값에 곱해주면 원래값이 나오겠다.

19)
어떤 근거에 의해서 만들어진지 알아보자.
shift row
아주 간단한 연산처럼 보인다.
동작 자체는 간단하기 하지만, 나름 그럴만한 이유가 있다.
state가 중간중간 인풋이 되기도하고, 아웃풋이 되기도 하는데
이걸 4바이트 단위의 컬럼으로 볼거다, 라고 얘기했다.
![보안 6주차 보강 (6단원)-23](images/보안%206주차%20보강%20(6단원)-23.png)

이거.
이렇게 컬럼에 관한 연산만 반복하게되면 4덩이가 안섞인다.
그래서 이 4덩이가 잘 섞이게 하도록 하는게 쉬프트 로우다.

복잡하게 얘기하지만,
기본적으로 
1.입력의 일부분의 출력의 여러부분에 분산해서 영향을 미치도록해준다.
2.입력과 출력사이에 관계가 자명하게 드러나지않도록, 복잡하게 하도록 한다.
이게 핵심인데,
그중에 서로 여러군데 영향을 미치기 위해 열로 배열했던걸 행간의 이동을 한것.

인크립션할 당시에 보면,
플레인텍스트의 첫번째 4바이트가 첫번째 컬럼으로 들어가고
라운드 키가 영향을 미치게되는데,
행에서 이동시키게되면 서로 넓은 부분에 영향을 미치게 된다.

한 컬럼에 있는 4개의 바이트들의 다른 4개의 컬럼에 영향을 주도록.
![보안 6주차 보강 (6단원)-24](images/보안%206주차%20보강%20(6단원)-24.png)

이렇게.

20)
믹스컬럼

길게얘기하면 너무 복잡하고 축약해서 얘기하면, 
컬럼내의 바이트 1개가, 해당 컬럼내의 4개의 바이트에게 모두 영향을 미치도록 되어있다.(행렬곱을 하면서)

믹스컬럼과 쉬프트로우를 동시에 순차적으로 적용시키게되면
결국은 한군데의 영향이 열내에 전체적으로 미치면서 동시에 다른 컬럼에게 영향을 미치게 된다.
이걸 몇라운드 반복하게되면
한쪽의 바이트가 전체 모든 바이트에게 다 영향을 미치게 된다.

21)
마지막 4번째 트랜스폼
이건 단순 xor
128비트 스테이트를 128비트 라운드키를 비트와이즈 xor시키는것.
컬럼와이즈로 보면 4개의 워드들을 워드별로 xor시킨다고 볼수도있고,
16개의 바이트를 바이트 별로 xor한다고 볼 수 있다.

이거 자체는 간단하지만,
round key expansion하는 과정은 간단하지않다..
여기서 복잡한 연산을 줘서 키 부분이 싸이퍼텍스트에 전체적인 부분에 영향을 미치면서
동시에 키와 싸이퍼텍스트의 관계가 복잡해지도록, 만드는 구조

22)
라운드 구조를 다시한번 보자.

4개의 트랜스폼으로 구성

subByte는 입력으로 들어가는게 16개의 바이트
각각의 바이트들을 4비트,4비트로 쪼개서 s-box의 인덱스와 매칭시켜서, 매칭되는 값을 출력으로 만드는.
이 과정을 각바이트별로 16번하는게 subByte의 결과
s-box는 미리 계산해서 가질 수 도있고, 사람마다 다른거쓰는게 아니라 다 똑같은거 쓴다.
=> 여기선 키가 전혀 적용되지 않았다

쉬프트로우
=> 여기서까지도 키가 전혀 적용x

믹스컬럼
컬럼별로봐서 한컬럼씩 행렬과 곱해주면서,
컬럼 하나하나의 바이트들을 GF(2^8)의 필드 원소로 보면서 행렬과 계산시켜서
이 컬럼에대한 행렬곱을 총 4번해서 아웃풋을 얻게되는게 믹스컬럼

믹스컬럼에서 쓰는 행렬도 누구나 같은거쓴다.
=> 역시나 여기서도 키안씀

=> 여기까지만하면 같은 플레인텍스트면 똑같은 값나옴

그러나 어떤 라운드키가 xor되느냐에 따라 전혀 다른 값이 될 수 있겠다.
따라 위의 3부분은 constant input,
addroundkey를 거친게 유일하게 키에따라서 바뀌는 variable input
-> AES라는 암호의 안전성을 좌우하는것은 키가 유일하다..
-> 키를 어떻게 잘 만드냐가 매우 중요하다

23)
서로 어떻게 영향을 미치는가를 표시한 그림
![보안 6주차 보강 (6단원)-25](images/보안%206주차%20보강%20(6단원)-25.png)

서브바이트는 다른데에 영향x
![보안 6주차 보강 (6단원)-26](images/보안%206주차%20보강%20(6단원)-26.png)

쉬프트로우를 거치면, 다른곳에 영향을줌
입력에 어떤 바이트가 1비트만 바뀌어도 전혀다른 값이 된다.
왜냐하면 GF상의 다항식에 대한 역원이 아예 바뀌므로.
따라서 위 그림의 예처럼 2번이 14번으로 쉬프트 될 때, 1비트만 바뀌어도 전혀다른 값으로 바뀐다.
![보안 6주차 보강 (6단원)-27](images/보안%206주차%20보강%20(6단원)-27.png)

믹스컬럼을 거치면서
바이트가 해당 컬럼에 전체 4바이트에게 영향을 미친다.
![보안 6주차 보강 (6단원)-28](images/보안%206주차%20보강%20(6단원)-28.png)

이게이제 에드라운드키를 거치면서 라운드 키와 xor되어서 나온다.

근데 라운드를 한 번더 반복한다고 하면,
![보안 6주차 보강 (6단원)-29](images/보안%206주차%20보강%20(6단원)-29.png)

완전 바뀐 바이트들이 쉬프트로우를 거치면서 다른곳들에 영향을 준다.

![보안 6주차 보강 (6단원)-30](images/보안%206주차%20보강%20(6단원)-30.png)

또 믹스컬럼을 거치면서 각 컬럼의 바이트가 컬럼전체에 영향을 미친다
…

=> 1비트를 바꾼효과가 2개 라운드돌았더니 전체 스테이트에 영향을 주는 상황이 되었다.
영향을 주는 것 뿐만아니라, 영향을 주는 관계식이 단순히 Xor와 같은 선형식이 아니라 복잡한식이라서
일부 정보를 공격자가 알아도 키(라운드키)에 관한 정보를 알아내기 어렵다,

이것이 AES의 설계 원칙

24)
지금까지는 인크립션 과정이었고, 디크립션 과정을 보자.

키는 암호화때와 똑같이 expand한 키를 적용. 다만 거꾸로부터 적용하겠지.

add round key - xor, 자기 자신이 역연산
믹스컬럼스 - 행렬곱이었으니까 역행렬을 곱하면 역연산
쉬프트로우스 - 반대로 이동시키면 역연산
sub byte - 반대로 subtitution하는 인버스테이블 적용
..

쭉 스테이트가 변화는 과정을 거꾸로 따라가면 플레인텍스트를 얻을 수 있다

이러한 구조가 SPN(Subtituion-Permutation Network)구조이다.

25)
그럼 이제 키를 어떻게 만들어내느냐.
AES의 키 익스팬션 과정

16바이트 키를 입력으로 받아서 176바이트의 키를 만들어내는 과정
(128비트 키, 10라운드 기준)

키가 일단 첫번째 4개의 워드로 카피될것. 이건 처음에 쓰임. (라운드1들어가기전 에드라운드키)
나머지 40개의 워드들을 생성하는 과정이
이전 4개의 워드들에 영향을 받아 다음 4개의 워드를 생성하는 방식.

말로하면 어려우니 그림으로

26)
키가 128비트 입력으로 들어왔다. k0 ~ k15가 각각 1바이트씩
열별로 모으면 1개의 워드가 되는것. 32비트 워드가 4개가 있는것.

w0~w3이 최초에 입력 받았던 키

이걸 가지고
![보안 6주차 보강 (6단원)-31](images/보안%206주차%20보강%20(6단원)-31.png)

이러한 과정을 10번거쳐서 10개의 라운드키를 만들어낸다.

g 함수를 사용하게되는데, 페이스텔 싸이퍼에서 했었던 f와 비슷한개념.
현재 128비트의 키로부터 다음라운드의 128비트 키를 만들어내는데,
그때 마지막 4번째 워드에 대해 g함수를 통과시키고 첫번째 워드(w0)와 xor시켜서 w4를 만들어낸다.	
g함수는 32비트 입력받아서 32비트를 출력해주는 함수

그니까 생성되는 4개의 워드중에 첫번째 워드는 특별한 방식으로 w3가 g함수를 거쳐서 w0와 xor가 되는 방식으로 생성되는 형태고,
나머지 3개의 워드는 단순히 이전라운드의 워드와 방금 생성된 워드를 xor 시키는 방식.

식으로 표현해보면
![보안 6주차 보강 (6단원)-32](images/보안%206주차%20보강%20(6단원)-32.png)

이렇게 키를 생성해낸다.

![보안 6주차 보강 (6단원)-33](images/보안%206주차%20보강%20(6단원)-33.png)

k0는 1라운드 들어가기 전에 적용,
k1~k10는 각 라운드에 적용

그럼 g함수가 뭐냐
32비트를 입력받으면 각각의 바이트로 짤라낸다.
위치이동(퍼뮤테이션)을 시킨다., 바이트 단위의 로테이션
그 후 각각의 바이트에 대해 s-box를 통과시킨다.
그 후 정해저있는 상수값과 xor시킨다.
그 상수값의 맨첫번째는 몇번째 라운드냐에 따라 달라지고, 나머지 3개는 0으로 고정
![보안 6주차 보강 (6단원)-34](images/보안%206주차%20보강%20(6단원)-34.png)

그다음 키를 생성한다고 하면
![보안 6주차 보강 (6단원)-35](images/보안%206주차%20보강%20(6단원)-35.png)

이렇게 될텐데, 이 때 g에서는 다 똑같은데 저 RC값만 바뀌는것. RC2로 (2라운드니까)
![보안 6주차 보강 (6단원)-36](images/보안%206주차%20보강%20(6단원)-36.png)

RC는 1을 왼쪽으로 한칸씩 쉬프트시키는 형태인데,
RC9은 더이상 쉬프트 시킬 공간이없다.
-> x^8을 모듈러 연산시킨다. 위의 모듈러스로
RC10은 똑같이 RC9값에 x를 곱한 값. (왼쪽으로 한칸 쉬프트)

이런식으로 생성.

27)
키 익스팬션 알고리즘, 왜 이렇게 설계했냐

이 알고리즘이 알려진 암호학적인 공격에 안전하도록 감안했고,
라운드에 의존하는 constant(RC)값을 쓰게 함으로써 규칙성을 없애는 것을 목표로 했다.

이렇게 하는 궁극적 목표는
암호화하는데 사용된 키의 일부분을 안다고해도, 11개 라운드키중에 1-2개 안다고해도
다른 라운드키를 만들지 못하게, 구조를 복잡하게 만들겠다는 것.

구조는 복잡해도 사실상 테이블찾아보기 xor 연산, 쉬프트시키기 이런거뿐이므로
일반적인 컴퓨터에서는 빠르게 돌아간다.

싸이퍼의 키의 diffusion이 라운드 키에 적용이 된다,
diffusion : 어떤 1비트의 변화가 여러 비트에 영향을 미치는 효과. 우리 말로 확산.
-> 키의 약간의 변화가 모든 라운드키에 확산되서 영향을 미치도록 했다는 뜻

s-box를 사용하면서, s-box내부가 곱셈의 역원으로 구성되어있기 때문에 
선형이아닌 성질을 제공.
-> 특정 비트를 안다고 해서 나머지 비트를 연립방정식을 쉽게 알 수 있는 상황은 배제

28)
입력의 변화가 출력에 어떻게 영향을 미치는지를 보자.

![보안 6주차 보강 (6단원)-37](images/보안%206주차%20보강%20(6단원)-37.png)

위 아래 둘다 플레인텍스트.
16진수로 쓴거라 2개씩 끊은게 1개의 바이트겠다. 
플레인 텍스트 중에 딱 1비트 바뀜. 0000 이 0001로.

각 라운드를 거쳤을 때 얼마나 달라지는지 보자
키는 당연히 같은거 적용했을때

round 0은 128비트 0번 라운드 키와 xor 시킨 결과.

1라운드를 거치면 차이나는 비트가 20개

1라운드 더 거치면 차이나는 비트가 58비트정도가 달라지는데, 전체가 거의 달라진다.
이게 라운드를 거칠수록 계속늘어나진 않고 그이후로는 비슷한 수준이다. 64비트 근처에서.

많이 바뀔수록 좋은거아니냐 -> 아니다. 64비트정도 바뀌는게 제일 좋다.
왜그러냐.
암호화라고 생각하지말고
128비트를 입력했을때 완전 랜덤하게 128비트의 아웃풋을 만든다고 가정해보자.
그 다음에 1/2 동전던지기 처럼 또 랜덤 128비트 를 만들었다고 가정.

처음만든 128비트와, 새로만든 128비트가 관계가 어떨가.
전부다 다를까?
아니다.
동전던지기를 하면 1/2 확률로 서로 다를수도있고 같을수도 있기 때문에
128비트를 랜덤하게 2번뽑으면 대략 64비트정도는 서로같고, 64비트는 다르다.
이게 랜덤의 성질.

암호에서 원하는건 가장 랜덤해보이기를 원하는것.
따라서 서로다른 2개의 출력이 64비트 정도 다른게 이상적
이미 2라운드 거쳤을때부터 이상적인 모습을 보인다고 할 수 있다.

29)
조금 다른 예제.
같은 플레인텍스트인데 키가 1비트 다를때.

여전히 위와 비슷한 성격을 보여준다.

이런것을 산사태, 눈사태효과(Avalanche effect)
조그만한 변화가 겉잡을 수 없이 퍼지면서 넓은  영역에 영향을 미친다고 해서.
AES가 이런 측면에서 키의 변화나 플레인텍스트의 변화나 확산(diffusion)의 효과가 매우 좋다

30)
마지막 페이지.

구현상의 관점에서 봤을때 AES의 장점

안전성도 안전성인데 여러가지 프로세서상에서 효율적으로 잘 구현될 수 있음
바이트 단위의 연산이다보니까 8비트의 워드 구조를 가진 cpu에서 잘 동작한다. 
요즘에 8비트 쓰는 cpu가 있냐?
컴퓨터나 스마트폰에 대부분 32비트나 64비트 쓰지만
low-end divice(iot같은거)는 8비트 많이쓴다. 이런 8비트 프로세서에서 잘동작한다.

구성연산들도 Xor라든지, 쉬프트라든지, 256바이트의 테이블을 가져오는거 정도가 전부이고
믹스컬럼도 간단한 행렬연산(그나마 가장복잡한 연산)

이게 다 바이트단위로 되는 연산

31)
그럼 우리가쓰는 컴퓨터나 스마트폰은 8비트 단위가 아닌데,
8비트 단위로 최적화한게 의미가 있냐.

당연히 32비트 프로세서에서도 잘동작한다.

ByteSub(BS), Shift row(SR), MixColums(MC)을 한 단위로 합칠 수 있다. 메모리가 충분하면. 4kb정도.
-> 이걸 테이블 lookup한번으로 해결.
거기에 addroundkey xor만 하면됨.

그런데 테이블이 4개가 필요해서 테이블 룩업4번, xor4번으로 1라운드가 끝나게 할 수 있다.
-> 굉장히 효율적

이런 효율적인 구현특성이 aes를 설계하는데 중요한 고려사항 중 하나였고,	 
이 성능의 장점이 라인달 알고리즘이 표준으로 되는데 중요한 역할을 하지 않았을까.
NIST 홈페이지에 자세히 나와있다.

32)
AES가 중요하게 여러분야에서 쓰이고 있다.

최근에는 AES 인크립션을 수행하는 전용 instruction들도 설계가 되었다.

예를 들어 인텔cpu에 보면 NI(new instructions)라고하는 계열의 명령어가 있는데 aes 수행만을 위한 별도의 명령어
무슨말이냐면 어셈블리로 프로그래밍하면 어셈블리어 명령어들이 따로있듯이,
그것처럼 aes 용 명령어가 따러있다는 뜻.
각 라운드 인크립션이나 디크립션에 관한 별도의 명령어들이 있다.

자세한 사항은 iclass에 올렸다.

33)
요약.

