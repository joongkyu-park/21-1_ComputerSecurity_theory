# 보안 2주차 이론

3)
이 페이지를 똑같이 적고, 대략 무엇인지 설명할 수 있는 게 오늘 목표

4)
컴퓨터 보안이란?
NIST에서 쓴 책에 나온 정의를 보통 사용한다.

컴퓨터보안은 보호이다. ~~을 보호
대상은 정보시스템

우리가 쓰는 컴퓨터를 포함한 정보시스템의 모든 자원들을,
integrity, availability, confidentiality 와 같은 기능들을 달성하는 것이 목표
위의 3가지 기능을 CIA라고 한다

5)
Confidentiality : 기밀성
- 데이터 confidentiality 정보를 볼권한이 없는 사람한테 정보가 공개되면 안됟나
- Privacy 제어권 :내 개인정보들이 특정목적을 위해 사용되고, 언제까지사용되고, 내가 요청을하면 더이상 공유를 원하지않으면 중지요청을하고.. 이러한 제어권을 정보의 주인이 가지는것 유럽의 경우 GDPR

Integrity : 무결성
- 정보나 프로그램같은것들이 미리 명세된 허가받은 방법으로만 변경가능하다 -> 허가받지않는사람, 방법들로 막 바꿀수 없다
- 시스템 인테그리티 시스템 자체(os의 커널같은거)가 외부의해킹이나 부주의한사용,실수에 의해서도 원래의 상태를 잃고 그러면 안됨

Availability : 가용성
- 서비스는 항상 가용한 상태여야한다. 서비스를 이용할 권한이 있는 유저들은.

이 3가지를 CIA triad라고 한다.

6)
CIA말고도 2개더
Accountability :설명가능한, 책임지는 -> 책임소재에 관한 문제
Authenticity : 진정성, 인증 -> 인증에 관한 문제

7)
이러한 이론적인 목표를 달성하기위해 취해야할 것들
10개의 목표가 나와있지만 빨간박스 위주로 알아보자

- 포텐셜 어택을 고려해한다.
- constant 모니터링이 필요하다… 24시간 내내
- 보안의 사고가 발생하기 전까지 미연의 방지하기 위한 수단에 투자를 하는데, 사고가 발생하기전까지는 그 투자의 효용을 알수 없다..

P : 보안사고가 발생할 확률
M : 사고가 발생했을 때 수습한 비용
I : 보안에 투자하는 비용

P*M < I 이면 보안에 투자를 안하는게, 금전적으로 맞다

- 보안기능 자꾸 강화하게되면 시스템의 성능을 떨어뜨릴 수있고, 사용자 입장에서는 불편하다

=> 모든 보안을 적용하는게 어렵다..

8)
OSI 보안 아키텍처
- 보안공격
- 보안절차, 또는 장치
- 보안서비스 -> 위의 개념보다 한단계 위에있는 목표 위의 보안 메커니즘을 이용해 보안 어택을 막는것

9)
Threat vs Attack

Threat : 포텐셜. 잠재적인것. 아직 일어지 않음
Attack : 실제 발생함. 결과.

10)
- passive attack 시스템의 상태 자체에는 영향 x, 그냥 몰래보는거 Ex) bob: 송신자, alice: 수신자 공개된 채널을 통해 중요한 정보를 보내려함 darth라는 애가 중간에 정보를 몰래봄. darth가 복사해서 가져가면, alice입장에서는 정보가 유출됐는지 알일이 없다. 결론적으론 bob은 정상적으로 보냈고, alice는 정상적으로 받았으니 시스템적으론 문제가없다.
- active attack  1: 중간에 바꿔서보냄 2:보내지도않았는데 중간에서 다른걸 보냄 3: 아예 가지못하게 막음 -> 전체 시스템이 변함

11) 어떻게 막을까 가져가는거 자체를 막을순없다..
-> darth가 메세지를 가져가도, 암호화를 하여 봐도 모르게 한다.
=> 완벽한 방법인가?
traffic analysis : 메세지가 가고있다는 사실자체가 의미를 줄 수 있다.

12)
액티브 어택
- Masquerade : 신원을 가장해서 보내는거. 대표적으로 forgery(위조)
- Replay 뭔가 새로만드는 건아닌데, 기존의 정상적인 패킷을 공격자가 저장해놨다가 다른시점에 보내는것. 일종의 신원가장, 위조, 변조라고도 볼 수 있음. ex) 밥이 앨리스에게 100만원을 송금함 이라는 패킷을 다른시점에 10번보내면..?
- 메세지를 변형. 
- 메세지가 가는걸 막아버림. 서비스 거부 공격

13)
데이터 컨피덴셜리티
데이터 자체에대한 보호
트래픽 플로우에 대한 보호(source to destination, frequency…, 내용은 모르지만)

14)
무결성

15)
connection-oriented 대표적 -> TCP 	-> 많은것들이 무결성에 위배
connectionless 대표적 -> UDP
	-> 메세지 내용자체가 변했냐 아니냐가 무결성의 중요요소

16)
가용성
denial-of service attack을 막는것이 중요

17)
진정성을 보장 -> 인증

18)
nonrepudiation : 부인방지, 부인봉쇄
데이터를 받았다는걸 부인하는걸 못하게.

19)
access control
시스템이나 프로그램에 대해서 접근에 제한,제어를 가하는것

20)
코어컨셉설명

어택중에 release of contents만 패시브어택

20)
13가지 보안설계원리?

21)
- 복잡한거보다 단순한게 낫다
- Fail-safe defaults -> ⭐️중요 access control을 할때 permission 기반이 좋다(whitelist 방식)  blacklist: 나쁜사람들 막기 whitelist: 모두 막고 권한이 있는사람만 들어오게  리눅스의 iptable 은 좋은 방법이아니다..

22)
- 접근제어가 필요할때마다 그때그때 다시 체크해라.
- 오픈디자인, 개방형 설계

23)
- 권한분할, 권한을 세분화 시켜서 관리
- 권한의 최소화. 쓸데없이 필요없는 권한 주지말라 -> 이 권한에 입각하여 만든거 : role-basd access control(RBAC)

24)
- 공통되는 메커니즘 최소한으로 해라
- 직관적이고 사람들이 심리적으로 받아들일 수 있는 방식이어야함

25)
- Isolation
- Encapsulation

26)
- Modularity
- Layering

27)
- Least astonihment : 가능한한 직관적이고 이해하기쉽게

28)
attack surface

31)
공격자입장에서는 한길만 뚫으면 성공임

34)
요약

—추가자료 시작—

3)
access control
- 공격을 막는 가장 기본적인 방법. 공격이들어오는 처음위치에서 막는다.
- 데이터나 자원들을 보호하는 프로세스, 허가되지않는 공개, 부적한 변조로부터

4)
엑세스 컨트롤 정책, 메카니즘
- 보안정책 DAC, MAC
- 보안 메카니즘 ACM, ACL

5)
보안정책
DAC : Discretionary access control, 임의적 접근 제어
주인이 모든 권한을 엑세스하다보니까, 파일 하나하나별로 명세를 할 수 있다.
세분화된 fine-grained 컨트롤이 가능하다.
but,사용자를 믿을 수 없음.

6)
MAC
사용자가아니라 시스템 자체가 권한을 부여함

rule-based access control (RBAC 아님!! 여기서 R은 role)

7)
엑세스 컨트롤 모델들

8)
엑세스 컨트롤 행렬(ACM)
일종의 테이블.

9) 행렬 예시

10)
비효율적이다. ,,

오브젝트 기준으로 압축 : ACL
서브젝트 기준으로 압축 : CL

